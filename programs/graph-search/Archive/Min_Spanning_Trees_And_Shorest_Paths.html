<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lecture 11 â€” Minimum Spanning Trees & Shortest Paths</title>
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=Fira+Code:wght@400;500&family=Lora:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:       #0d0f14;
    --bg2:      #13161d;
    --bg3:      #1a1e28;
    --border:   #252a37;
    --text:     #cdd3e0;
    --text-dim: #6b7590;
    --gold:     #f0b429;
    --teal:     #2dd4bf;
    --rose:     #fb7185;
    --violet:   #a78bfa;
    --green:    #4ade80;
    --blue:     #60a5fa;
    --orange:   #fb923c;
    --glow-gold: 0 0 20px rgba(240,180,41,0.25);
    --glow-teal: 0 0 20px rgba(45,212,191,0.25);
    --glow-rose: 0 0 20px rgba(251,113,133,0.25);
    --radius:   12px;
  }

  * { margin:0; padding:0; box-sizing:border-box; }

  html { scroll-behavior: smooth; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Lora', serif;
    font-size: 17px;
    line-height: 1.75;
  }

  /* â”€â”€ HEADER â”€â”€ */
  header {
    position: relative;
    overflow: hidden;
    padding: 80px 40px 60px;
    text-align: center;
    background: linear-gradient(160deg, #0d0f14 0%, #111624 60%, #0d1020 100%);
    border-bottom: 1px solid var(--border);
  }
  header::before {
    content:'';
    position:absolute; inset:0;
    background: radial-gradient(ellipse 70% 60% at 50% -10%, rgba(240,180,41,0.12) 0%, transparent 70%);
    pointer-events:none;
  }
  .lecture-badge {
    display:inline-block;
    font-family:'Syne',sans-serif;
    font-size:11px; font-weight:700; letter-spacing:3px; text-transform:uppercase;
    color:var(--gold); border:1px solid rgba(240,180,41,0.4);
    padding:5px 14px; border-radius:30px; margin-bottom:24px;
    background:rgba(240,180,41,0.07);
  }
  header h1 {
    font-family:'Syne',sans-serif;
    font-size:clamp(2rem,5vw,3.6rem);
    font-weight:800; letter-spacing:-1px; line-height:1.1;
    background: linear-gradient(135deg, #f0b429 0%, #ffd97d 40%, #fb923c 100%);
    -webkit-background-clip:text; -webkit-text-fill-color:transparent;
    background-clip:text; margin-bottom:16px;
  }
  header p {
    color:var(--text-dim); font-size:1.05rem; max-width:580px; margin:0 auto 36px;
  }
  .toc-chips { display:flex; flex-wrap:wrap; justify-content:center; gap:8px; }
  .toc-chips a {
    font-family:'Syne',sans-serif; font-size:12px; font-weight:600; letter-spacing:.5px;
    padding:6px 16px; border-radius:30px; text-decoration:none;
    border:1px solid var(--border); color:var(--text-dim);
    transition:all .25s; background:var(--bg2);
  }
  .toc-chips a:hover { color:var(--gold); border-color:var(--gold); background:rgba(240,180,41,0.07); }

  /* â”€â”€ LAYOUT â”€â”€ */
  main { max-width:980px; margin:0 auto; padding:0 28px 80px; }

  /* â”€â”€ SECTION â”€â”€ */
  section {
    padding: 64px 0 32px;
    border-bottom: 1px solid var(--border);
  }
  section:last-child { border-bottom:none; }

  .section-label {
    font-family:'Syne',sans-serif; font-size:11px; font-weight:700;
    letter-spacing:3px; text-transform:uppercase; color:var(--text-dim);
    margin-bottom:10px;
  }
  h2 {
    font-family:'Syne',sans-serif; font-size:clamp(1.6rem,3.5vw,2.4rem);
    font-weight:800; letter-spacing:-0.5px; line-height:1.15;
    margin-bottom:20px; color:#e8edf5;
  }
  h2 span { color:var(--gold); }
  h3 {
    font-family:'Syne',sans-serif; font-size:1.25rem; font-weight:700;
    color:#dde2ef; margin:36px 0 12px;
  }
  h4 {
    font-family:'Syne',sans-serif; font-size:1rem; font-weight:700;
    color:var(--teal); margin:28px 0 10px; letter-spacing:.5px;
  }
  p { margin-bottom:16px; }
  strong { color:#e8edf5; font-weight:600; }
  em { color:var(--gold); font-style:normal; font-weight:500; }

  /* â”€â”€ ANALOGY BOXES â”€â”€ */
  .analogy {
    border-left:3px solid var(--teal); background:rgba(45,212,191,0.06);
    border-radius:0 var(--radius) var(--radius) 0;
    padding:18px 22px; margin:24px 0;
  }
  .analogy-label {
    font-family:'Syne',sans-serif; font-size:11px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:var(--teal);
    margin-bottom:8px;
  }
  .analogy p { margin:0; color:#b8c2d4; }

  /* â”€â”€ DEFINITION BOXES â”€â”€ */
  .definition {
    border:1px solid rgba(167,139,250,0.35); background:rgba(167,139,250,0.06);
    border-radius:var(--radius); padding:20px 24px; margin:24px 0;
  }
  .definition-label {
    font-family:'Syne',sans-serif; font-size:11px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:var(--violet);
    margin-bottom:10px;
  }
  .definition p { margin:0; color:#cdd3e0; }

  /* â”€â”€ PROOF BOXES â”€â”€ */
  .proof {
    border:1px solid rgba(251,113,133,0.3); background:rgba(251,113,133,0.05);
    border-radius:var(--radius); padding:20px 24px; margin:24px 0;
  }
  .proof-label {
    font-family:'Syne',sans-serif; font-size:11px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:var(--rose);
    margin-bottom:10px;
  }
  .proof p { margin:0 0 10px; color:#cdd3e0; font-size:.95rem; }
  .proof p:last-child { margin:0; }

  /* â”€â”€ KEY INSIGHT â”€â”€ */
  .key-insight {
    background: linear-gradient(135deg, rgba(240,180,41,0.1), rgba(251,146,60,0.06));
    border:1px solid rgba(240,180,41,0.3); border-radius:var(--radius);
    padding:20px 24px; margin:24px 0;
    display:flex; gap:14px; align-items:flex-start;
  }
  .key-insight .icon { font-size:1.5rem; flex-shrink:0; margin-top:2px; }
  .key-insight p { margin:0; color:#dde2ef; }

  /* â”€â”€ CODE â”€â”€ */
  .code-wrap {
    background:var(--bg2); border:1px solid var(--border);
    border-radius:var(--radius); overflow:hidden; margin:24px 0;
  }
  .code-header {
    background:var(--bg3); padding:10px 18px;
    display:flex; justify-content:space-between; align-items:center;
    border-bottom:1px solid var(--border);
  }
  .code-lang {
    font-family:'Syne',sans-serif; font-size:11px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:var(--text-dim);
  }
  .code-title { font-family:'Syne',sans-serif; font-size:12px; color:var(--text-dim); }
  pre {
    padding:22px 24px; overflow-x:auto; font-family:'Fira Code',monospace;
    font-size:13.5px; line-height:1.7; color:#cdd3e0;
  }
  .kw  { color:#c792ea; }
  .fn  { color:#82aaff; }
  .tp  { color:#ffcb6b; }
  .cm  { color:#546e7a; font-style:italic; }
  .st  { color:#c3e88d; }
  .nm  { color:#f78c6c; }
  .op  { color:#89ddff; }

  /* â”€â”€ STEP TRACE â”€â”€ */
  .trace-container { margin:24px 0; }
  .trace-title {
    font-family:'Syne',sans-serif; font-size:12px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:var(--text-dim);
    margin-bottom:12px;
  }
  .trace-step {
    background:var(--bg2); border:1px solid var(--border);
    border-radius:var(--radius); padding:16px 20px; margin-bottom:10px;
    transition:border-color .2s;
  }
  .trace-step:hover { border-color:var(--gold); }
  .trace-step-header {
    display:flex; align-items:center; gap:12px; margin-bottom:8px;
  }
  .step-num {
    background:var(--gold); color:var(--bg); font-family:'Syne',sans-serif;
    font-size:12px; font-weight:800; width:28px; height:28px;
    border-radius:50%; display:flex; align-items:center; justify-content:center;
    flex-shrink:0;
  }
  .step-num.teal  { background:var(--teal); }
  .step-num.rose  { background:var(--rose); }
  .step-num.violet{ background:var(--violet); }
  .step-num.green { background:var(--green); }
  .step-title {
    font-family:'Syne',sans-serif; font-size:.95rem; font-weight:700;
    color:#dde2ef;
  }
  .step-body { color:#b8c2d4; font-size:.93rem; padding-left:40px; }
  .step-body code {
    font-family:'Fira Code',monospace; font-size:12px;
    background:var(--bg3); padding:2px 7px; border-radius:5px; color:var(--teal);
  }
  .step-body .accepted { color:var(--green); font-weight:600; }
  .step-body .rejected { color:var(--rose); font-weight:600; }

  /* â”€â”€ COMPARISON TABLE â”€â”€ */
  .compare-table-wrap { overflow-x:auto; margin:24px 0; }
  table { width:100%; border-collapse:collapse; }
  th {
    font-family:'Syne',sans-serif; font-size:12px; font-weight:700;
    letter-spacing:1px; text-transform:uppercase;
    color:var(--text-dim); padding:12px 16px; text-align:left;
    background:var(--bg3); border-bottom:2px solid var(--border);
  }
  td {
    padding:13px 16px; border-bottom:1px solid var(--border);
    font-size:.92rem; color:#cdd3e0; vertical-align:top;
  }
  tr:last-child td { border-bottom:none; }
  tr:hover td { background:rgba(255,255,255,0.02); }
  td code {
    font-family:'Fira Code',monospace; font-size:12px;
    background:var(--bg3); padding:2px 7px; border-radius:5px; color:var(--teal);
  }
  .tag {
    display:inline-block; font-family:'Syne',sans-serif; font-size:11px;
    font-weight:700; letter-spacing:.5px; padding:2px 9px; border-radius:20px;
  }
  .tag-gold   { background:rgba(240,180,41,0.15); color:var(--gold); }
  .tag-teal   { background:rgba(45,212,191,0.15); color:var(--teal); }
  .tag-rose   { background:rgba(251,113,133,0.15); color:var(--rose); }
  .tag-violet { background:rgba(167,139,250,0.15); color:var(--violet); }
  .tag-green  { background:rgba(74,222,128,0.15); color:var(--green); }
  .tag-blue   { background:rgba(96,165,250,0.15); color:var(--blue); }

  /* â”€â”€ SVG GRAPHS â”€â”€ */
  .graph-card {
    background:var(--bg2); border:1px solid var(--border);
    border-radius:var(--radius); padding:28px; margin:24px 0;
  }
  .graph-card-title {
    font-family:'Syne',sans-serif; font-size:12px; font-weight:700;
    letter-spacing:2px; text-transform:uppercase; color:var(--text-dim);
    margin-bottom:18px; text-align:center;
  }
  svg { display:block; margin:0 auto; }
  .node circle { cursor:pointer; transition:r .2s; }
  .node circle:hover { r:18; }
  .node text { font-family:'Syne',sans-serif; font-size:13px; font-weight:800; }
  .edge-label { font-family:'Fira Code',monospace; font-size:11px; }

  /* â”€â”€ ALGO CARD â”€â”€ */
  .algo-card {
    background:var(--bg2); border:1px solid var(--border);
    border-radius:var(--radius); overflow:hidden; margin:24px 0;
  }
  .algo-card-header {
    padding:18px 24px; display:flex; align-items:center; gap:14px;
    border-bottom:1px solid var(--border);
  }
  .algo-icon {
    width:42px; height:42px; border-radius:10px;
    display:flex; align-items:center; justify-content:center;
    font-size:1.3rem; flex-shrink:0;
  }
  .algo-card-body { padding:22px 24px; }
  .stats-row {
    display:flex; flex-wrap:wrap; gap:16px; margin-top:16px;
  }
  .stat-pill {
    background:var(--bg3); border:1px solid var(--border);
    border-radius:8px; padding:8px 16px;
    font-family:'Syne',sans-serif; font-size:12px;
  }
  .stat-pill span { display:block; color:var(--text-dim); font-size:10px; letter-spacing:1px; text-transform:uppercase; margin-bottom:3px; }
  .stat-pill strong { font-size:15px; font-family:'Fira Code',monospace; }

  /* â”€â”€ CALLOUT â”€â”€ */
  .callout {
    display:flex; gap:14px; align-items:flex-start;
    background:var(--bg2); border:1px solid var(--border);
    border-radius:var(--radius); padding:18px 20px; margin:20px 0;
  }
  .callout .ci { font-size:1.2rem; flex-shrink:0; margin-top:2px; }
  .callout p { margin:0; font-size:.93rem; color:#b8c2d4; }
  .callout.warn { border-color:rgba(251,113,133,0.3); background:rgba(251,113,133,0.05); }
  .callout.warn .ci::before { content:'âš ï¸'; }
  .callout.info { border-color:rgba(96,165,250,0.3); background:rgba(96,165,250,0.05); }
  .callout.info .ci::before { content:'ğŸ’¡'; }
  .callout.success { border-color:rgba(74,222,128,0.3); background:rgba(74,222,128,0.05); }
  .callout.success .ci::before { content:'âœ…'; }

  /* â”€â”€ COMPLEXITY VISUAL â”€â”€ */
  .complexity-bar-wrap { margin:20px 0; }
  .cbar-row { display:flex; align-items:center; gap:14px; margin-bottom:14px; }
  .cbar-label { width:130px; flex-shrink:0; font-family:'Syne',sans-serif; font-size:13px; font-weight:700; color:#dde2ef; }
  .cbar-track { flex:1; height:28px; background:var(--bg3); border-radius:6px; overflow:hidden; }
  .cbar-fill {
    height:100%; border-radius:6px;
    display:flex; align-items:center; padding:0 12px;
    font-family:'Fira Code',monospace; font-size:12px; font-weight:500;
    transition: width 1s cubic-bezier(.25,.46,.45,.94);
  }
  .cbar-fill.fast { background:linear-gradient(90deg,#059669,#34d399); width:30%; color:#d1fae5; }
  .cbar-fill.medium { background:linear-gradient(90deg,#d97706,#fbbf24); width:55%; color:#fef3c7; }
  .cbar-fill.slow { background:linear-gradient(90deg,#dc2626,#f87171); width:85%; color:#fee2e2; }

  /* â”€â”€ STEP INTERACTIVE â”€â”€ */
  .interactive-trace { margin:24px 0; }
  .it-controls { display:flex; gap:10px; margin-bottom:16px; align-items:center; }
  .it-btn {
    font-family:'Syne',sans-serif; font-size:12px; font-weight:700;
    letter-spacing:1px; padding:8px 18px; border-radius:8px; cursor:pointer;
    border:1px solid var(--border); background:var(--bg2); color:var(--text-dim);
    transition:all .2s;
  }
  .it-btn:hover { border-color:var(--gold); color:var(--gold); }
  .it-btn.active { background:var(--gold); color:var(--bg); border-color:var(--gold); }
  .it-step-display {
    background:var(--bg2); border:1px solid var(--border);
    border-radius:var(--radius); padding:22px 26px; min-height:120px;
  }
  .it-counter {
    font-family:'Syne',sans-serif; font-size:11px; letter-spacing:2px;
    text-transform:uppercase; color:var(--text-dim); margin-bottom:12px;
  }
  .it-step-title { font-family:'Syne',sans-serif; font-size:1.1rem; font-weight:700; color:var(--gold); margin-bottom:8px; }
  .it-step-body { color:#b8c2d4; font-size:.92rem; }
  .it-step-body code { font-family:'Fira Code',monospace; font-size:12px; background:var(--bg3); padding:2px 7px; border-radius:4px; color:var(--teal); }

  /* â”€â”€ FOOTER â”€â”€ */
  footer {
    border-top:1px solid var(--border);
    padding:36px 28px; text-align:center;
    color:var(--text-dim); font-size:.85rem;
    font-family:'Syne',sans-serif; letter-spacing:1px;
  }

  /* â”€â”€ SCROLLBAR â”€â”€ */
  ::-webkit-scrollbar { width:6px; height:6px; }
  ::-webkit-scrollbar-track { background:var(--bg); }
  ::-webkit-scrollbar-thumb { background:var(--border); border-radius:3px; }

  /* â”€â”€ FADE IN â”€â”€ */
  @keyframes fadeUp {
    from { opacity:0; transform:translateY(24px); }
    to   { opacity:1; transform:translateY(0); }
  }
  section { animation: fadeUp .6s ease both; }

  /* responsive */
  @media(max-width:640px){
    header { padding:50px 20px 40px; }
    main { padding:0 16px 60px; }
    .stats-row { flex-direction:column; }
    .cbar-label { width:90px; }
  }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HEADER -->
<header>
  <div class="lecture-badge">Lecture 11 of 12 Â· Data Structures &amp; Algorithms</div>
  <h1>Minimum Spanning Trees<br>&amp; Shortest Paths</h1>
  <p>A complete beginner-friendly walkthrough of Kruskal's, Prim's, Dijkstra's, and Bellman-Ford algorithms â€” with full traces, visuals, and C++ code.</p>
  <div class="toc-chips">
    <a href="#intro">Edge-Weighted Graphs</a>
    <a href="#mst">Spanning Trees</a>
    <a href="#kruskal">Kruskal's</a>
    <a href="#prim">Prim's</a>
    <a href="#dijkstra">Dijkstra's</a>
    <a href="#bellman">Bellman-Ford</a>
    <a href="#compare">Comparison</a>
  </div>
</header>

<main>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART I -->
<section id="intro">
  <div class="section-label">Part I</div>
  <h2>Edge-<span>Weighted</span> Graphs</h2>

  <p>In earlier lectures you learned about plain graphs â€” networks of vertices connected by edges. But in the real world, connections have <strong>costs</strong>. A road has a distance. A network link has a latency. A flight route has a price. To model this we need <strong>edge-weighted graphs</strong>, where every edge carries a numerical weight.</p>

  <div class="analogy">
    <div class="analogy-label">Real-World Analogy</div>
    <p>Think of a map of cities connected by highways. Each highway has a length (in miles). That's an edge-weighted graph. The cities are <em>vertices</em>, the highways are <em>edges</em>, and the mileage is the <em>weight</em>.</p>
  </div>

  <h3>The Weighted Edge Object</h3>
  <p>Rather than just storing "there is a connection between A and B," we store the full triple: <strong>vertex A</strong>, <strong>vertex B</strong>, and the <strong>weight</strong>. In C++ this looks like:</p>

  <div class="code-wrap">
    <div class="code-header">
      <span class="code-lang">C++</span>
      <span class="code-title">Weighted Edge â€” the basic building block</span>
    </div>
    <pre><span class="cm">// â”€â”€â”€ WEIGHTED EDGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Stores the triple: (vertex A, vertex B, cost).
// Either endpoint can be called first, then other(x) gives the far side.
// operator&lt; enables sorting edges by weight for Kruskal's.
//
// Usage pattern:
//   int u = e.either();      // pick one endpoint
//   int v = e.other(u);      // get the other endpoint
//   double w = e.weight;     // get the cost
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">struct</span> <span class="tp">Edge</span> {
    <span class="tp">int</span>    v, w;       <span class="cm">// two endpoints of the edge</span>
    <span class="tp">double</span> weight;    <span class="cm">// the cost / distance / weight</span>

    <span class="cm">// Return either endpoint (call this first)</span>
    <span class="tp">int</span> <span class="fn">either</span>()          { <span class="kw">return</span> v; }

    <span class="cm">// Given one endpoint, return the OTHER endpoint</span>
    <span class="tp">int</span> <span class="fn">other</span>(<span class="tp">int</span> vertex) {
        <span class="kw">if</span> (vertex == v) <span class="kw">return</span> w;
        <span class="kw">if</span> (vertex == w) <span class="kw">return</span> v;
        <span class="kw">throw</span> <span class="st">"Inconsistent edge"</span>;
    }

    <span class="cm">// Allows sorting edges by weight (used by Kruskal's)</span>
    <span class="tp">bool</span> <span class="kw">operator</span><span class="op">&lt;</span>(<span class="kw">const</span> <span class="tp">Edge</span><span class="op">&amp;</span> that) <span class="kw">const</span> {
        <span class="kw">return</span> weight <span class="op">&lt;</span> that.weight;
    }
};</pre>
  </div>

  <div class="callout info"><div class="ci"></div><p>The <code>other(vertex)</code> method is brilliantly useful: when you're at one endpoint and want to find where the edge leads, just call <code>other(currentVertex)</code>. No if-else needed in client code.</p></div>

  <h3>The Edge-Weighted Graph</h3>
  <p>An edge-weighted graph stores an <strong>adjacency list</strong> â€” for each vertex, a list of all edges touching it. Since each edge is undirected, it appears in <em>two</em> lists (once for each endpoint).</p>

  <div class="code-wrap">
    <div class="code-header">
      <span class="code-lang">C++</span>
      <span class="code-title">WeightedGraph â€” adjacency-list representation</span>
    </div>
    <pre><span class="cm">// â”€â”€â”€ WEIGHTED GRAPH (Adjacency-List Representation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// adj[v] holds all edges that TOUCH vertex v.
// Each undirected edge is stored TWICE â€” once per endpoint.
//
// Example state after addEdge({A, B, 4.0}) and addEdge({A, C, 2.0}):
//   adj[A] = [ (A-B,4.0), (A-C,2.0) ]
//   adj[B] = [ (A-B,4.0) ]
//   adj[C] = [ (A-C,2.0) ]
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">class</span> <span class="tp">WeightedGraph</span> {
<span class="kw">public</span>:
    <span class="tp">int</span> V, E;                              <span class="cm">// vertex count, edge count</span>
    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;&gt;</span> adj;             <span class="cm">// adj[v] = list of edges at vertex v</span>

    <span class="fn">WeightedGraph</span>(<span class="tp">int</span> V) : V(V), E(<span class="nm">0</span>), adj(V) {}

    <span class="kw">void</span> <span class="fn">addEdge</span>(<span class="tp">Edge</span> e) {
        <span class="tp">int</span> v <span class="op">=</span> e.<span class="fn">either</span>();
        <span class="tp">int</span> w <span class="op">=</span> e.<span class="fn">other</span>(v);
        adj[v].<span class="fn">push_back</span>(e);   <span class="cm">// add to v's list</span>
        adj[w].<span class="fn">push_back</span>(e);   <span class="cm">// add to w's list (undirected = stored at BOTH ends)</span>
        E<span class="op">++</span>;
    }
};</pre>
  </div>

  <div class="definition">
    <div class="definition-label">Space Complexity</div>
    <p>The adjacency-list representation uses <strong>Î˜(V + E)</strong> space â€” one slot per vertex, plus two slots per edge (one for each endpoint's list). For sparse graphs (few edges), this is far better than a V Ã— V matrix.</p>
  </div>

  <h3>Directed vs. Undirected Weighted Graphs</h3>
  <p>For <strong>MST algorithms</strong> (Kruskal's, Prim's) we use <em>undirected</em> graphs â€” edges go both ways. For <strong>shortest path algorithms</strong> (Dijkstra's, Bellman-Ford) we use <em>directed</em> graphs â€” each edge has a specific direction (from â†’ to). A directed edge uses <code>from()</code> and <code>to()</code> instead of <code>either()</code> and <code>other()</code>, and is only added to <em>one</em> adjacency list.</p>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART II -->
<section id="mst">
  <div class="section-label">Part II</div>
  <h2>Minimum <span>Spanning</span> Trees</h2>

  <p>Given a connected, undirected, edge-weighted graph, a <strong>spanning tree</strong> is a subset of edges that connects every vertex with no cycles â€” the cheapest possible "backbone." The <strong>minimum spanning tree (MST)</strong> is the spanning tree with the smallest total edge weight.</p>

  <div class="analogy">
    <div class="analogy-label">Real-World Analogy</div>
    <p>You need to lay cables to connect 10 towns. Each possible cable segment has a cost. You want every town connected while spending the minimum total amount on cable. The set of cables you choose is the MST.</p>
  </div>

  <div class="definition">
    <div class="definition-label">Definition â€” Spanning Tree</div>
    <p>A spanning tree of a connected graph with <strong>V</strong> vertices is a subgraph that is:<br>
    (1) connected â€” you can reach every vertex,<br>
    (2) acyclic â€” no loops,<br>
    (3) has exactly <strong>V âˆ’ 1</strong> edges.</p>
  </div>

  <!-- SVG: example graph -->
  <div class="graph-card">
    <div class="graph-card-title">Example: 4-Vertex Graph &amp; Its MST</div>
    <svg width="520" height="200" viewBox="0 0 520 200">
      <!-- ORIGINAL GRAPH -->
      <text x="120" y="20" text-anchor="middle" font-family="Syne,sans-serif" font-size="12" fill="#6b7590" letter-spacing="2">ORIGINAL GRAPH</text>
      <!-- edges -->
      <line x1="80" y1="50" x2="160" y2="50" stroke="#3a4055" stroke-width="2"/>
      <text x="120" y="43" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#f0b429">4</text>
      <line x1="80" y1="50" x2="80" y2="140" stroke="#3a4055" stroke-width="2"/>
      <text x="68" y="100" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#f0b429">2</text>
      <line x1="80" y1="140" x2="160" y2="140" stroke="#3a4055" stroke-width="2"/>
      <text x="120" y="158" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#f0b429">5</text>
      <line x1="160" y1="50" x2="160" y2="140" stroke="#3a4055" stroke-width="2"/>
      <text x="172" y="100" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#f0b429">3</text>
      <line x1="80" y1="50" x2="160" y2="140" stroke="#3a4055" stroke-width="2"/>
      <text x="128" y="103" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#f0b429">7</text>
      <!-- nodes -->
      <circle cx="80" cy="50" r="16" fill="#1a1e28" stroke="#6b7590" stroke-width="2"/>
      <text x="80" y="55" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#cdd3e0">A</text>
      <circle cx="160" cy="50" r="16" fill="#1a1e28" stroke="#6b7590" stroke-width="2"/>
      <text x="160" y="55" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#cdd3e0">B</text>
      <circle cx="80" cy="140" r="16" fill="#1a1e28" stroke="#6b7590" stroke-width="2"/>
      <text x="80" y="145" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#cdd3e0">C</text>
      <circle cx="160" cy="140" r="16" fill="#1a1e28" stroke="#6b7590" stroke-width="2"/>
      <text x="160" y="145" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#cdd3e0">D</text>

      <!-- ARROW -->
      <text x="230" y="100" text-anchor="middle" font-size="24" fill="#f0b429">â†’</text>
      <text x="230" y="120" text-anchor="middle" font-family="Syne,sans-serif" font-size="10" fill="#6b7590">MST</text>

      <!-- MST GRAPH -->
      <text x="390" y="20" text-anchor="middle" font-family="Syne,sans-serif" font-size="12" fill="#6b7590" letter-spacing="2">MINIMUM SPANNING TREE</text>
      <!-- MST edges highlighted -->
      <line x1="350" y1="50" x2="350" y2="140" stroke="#2dd4bf" stroke-width="3"/>
      <text x="338" y="100" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#2dd4bf">2</text>
      <line x1="350" y1="140" x2="430" y2="140" stroke="#3a4055" stroke-width="2" stroke-dasharray="4,3"/>
      <line x1="430" y1="50" x2="430" y2="140" stroke="#2dd4bf" stroke-width="3"/>
      <text x="442" y="100" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#2dd4bf">3</text>
      <line x1="350" y1="50" x2="430" y2="50" stroke="#2dd4bf" stroke-width="3"/>
      <text x="390" y="43" text-anchor="middle" font-family="Fira Code,monospace" font-size="11" fill="#2dd4bf">4</text>
      <!-- nodes -->
      <circle cx="350" cy="50" r="16" fill="#1a1e28" stroke="#2dd4bf" stroke-width="2"/>
      <text x="350" y="55" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#2dd4bf">A</text>
      <circle cx="430" cy="50" r="16" fill="#1a1e28" stroke="#2dd4bf" stroke-width="2"/>
      <text x="430" y="55" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#2dd4bf">B</text>
      <circle cx="350" cy="140" r="16" fill="#1a1e28" stroke="#2dd4bf" stroke-width="2"/>
      <text x="350" y="145" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#2dd4bf">C</text>
      <circle cx="430" cy="140" r="16" fill="#1a1e28" stroke="#6b7590" stroke-width="2"/>
      <text x="430" y="145" text-anchor="middle" font-family="Syne,sans-serif" font-size="13" font-weight="800" fill="#cdd3e0">D</text>
      <text x="390" y="180" text-anchor="middle" font-family="Syne,sans-serif" font-size="11" fill="#6b7590">Total weight: 2+4+3 = 9 (minimum)</text>
    </svg>
  </div>

  <h3>The Cut Property â€” the Key Theorem</h3>
  <p>Every efficient MST algorithm is based on one powerful theorem: the <strong>Cut Property</strong>. Before we state it, we need to know what a "cut" is.</p>

  <div class="definition">
    <div class="definition-label">Definition â€” Cut</div>
    <p>A <strong>cut</strong> is any way of dividing the vertices into two non-empty groups: group S and group (V âˆ’ S). An edge <strong>crosses the cut</strong> if one endpoint is in S and the other is in V âˆ’ S.</p>
  </div>

  <div class="definition">
    <div class="definition-label">Proposition A â€” The Cut Property</div>
    <p>Let e be the <em>unique minimum-weight edge</em> that crosses any cut (S, V âˆ’ S). Then <strong>e must be in every MST</strong>.</p>
  </div>

  <div class="proof">
    <div class="proof-label">Proof (by contradiction)</div>
    <p>Suppose T is an MST that does <em>not</em> contain e. Since T is a spanning tree, it has a path from u to v (the endpoints of e). That path must cross our cut somewhere â€” at an edge f.</p>
    <p>Since e is the unique minimum-weight crossing edge, w(f) > w(e). Now swap f out for e: build T' = T âˆ’ {f} + {e}. T' is still a spanning tree, but its total weight is less than T's. Contradiction â€” T was supposed to be minimum! So e must be in the MST. âˆ</p>
  </div>

  <h3>The Cycle Property â€” what definitely is NOT in the MST</h3>

  <div class="definition">
    <div class="definition-label">Proposition B â€” The Cycle Property</div>
    <p>The <strong>maximum-weight edge in any cycle</strong> is <em>never</em> in the MST (assuming all weights are distinct).</p>
  </div>

  <div class="analogy">
    <div class="analogy-label">Why It Makes Sense</div>
    <p>If you have a loop, the most expensive edge in that loop is redundant â€” you can go around the loop the other way at lower cost. The MST would always prefer the cheaper route.</p>
  </div>

  <h3>The Generic Greedy MST Algorithm</h3>
  <p>Both Kruskal's and Prim's algorithms are special cases of this simple greedy recipe:</p>
  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">Pseudocode</span><span class="code-title">Generic Greedy MST</span></div>
    <pre><span class="cm">// â”€â”€â”€ GENERIC GREEDY MST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Plain English:
//   â‘  Start with an empty tree T
//   â‘¡ Find any cut where NO edge of T crosses it
//   â‘¢ Add the minimum-weight crossing edge to T
//   â‘£ Repeat until T has V-1 edges (spanning tree is complete)
//
// Kruskal's and Prim's each find the cut differently:
//   Kruskal's:  cuts separate components (tracked by Union-Find)
//   Prim's:     cut = {tree vertices} vs {non-tree vertices}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
T = {}  <span class="cm">// empty set â€” will become the MST</span>

<span class="kw">while</span> |T| &lt; V - 1:
    Find a cut where no edge of T crosses it
    Add the minimum-weight crossing edge to T

<span class="kw">return</span> T</pre>
  </div>
  <div class="callout success"><div class="ci"></div><p>Correctness is guaranteed by the Cut Property: at every step, the cheapest crossing edge must be in the MST â€” so we're always safe to add it.</p></div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART III: KRUSKAL -->
<section id="kruskal">
  <div class="section-label">Part III</div>
  <h2>Kruskal's <span>Algorithm</span></h2>

  <div class="algo-card">
    <div class="algo-card-header">
      <div class="algo-icon" style="background:rgba(240,180,41,0.15);">ğŸ”—</div>
      <div>
        <div style="font-family:Syne,sans-serif;font-size:1.1rem;font-weight:800;color:#e8edf5;">Kruskal's Algorithm</div>
        <div style="font-size:.88rem;color:var(--text-dim);">Sort all edges, greedily add the cheapest that doesn't create a cycle</div>
      </div>
    </div>
    <div class="algo-card-body">
      <div class="stats-row">
        <div class="stat-pill"><span>Time</span><strong style="color:var(--gold);">O(E log E)</strong></div>
        <div class="stat-pill"><span>Space</span><strong style="color:var(--teal);">O(V + E)</strong></div>
        <div class="stat-pill"><span>Data Structure</span><strong style="color:var(--violet);">Union-Find</strong></div>
        <div class="stat-pill"><span>Best For</span><strong style="color:var(--green);">Sparse Graphs</strong></div>
      </div>
    </div>
  </div>

  <h3>The Core Idea</h3>
  <p>Kruskal's strategy is beautifully simple: <strong>sort every edge in the graph by weight</strong> (cheapest first), then walk through the sorted list and add each edge to the MST â€” <em>unless</em> it would create a cycle (connecting two vertices already in the same component).</p>

  <div class="analogy">
    <div class="analogy-label">Analogy â€” Building a Road Network</div>
    <p>Imagine you have a list of all possible roads, sorted by construction cost. You build the cheapest road first, then the next cheapest, skipping any road that would create a redundant loop (both towns it connects are already reachable from each other).</p>
  </div>

  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">C++</span><span class="code-title">Kruskal's MST Algorithm</span></div>
    <pre><span class="cm">// â”€â”€â”€ KRUSKAL'S MST ALGORITHM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Plain English:
//   â‘  Collect ALL edges and sort them cheapest-first          O(E log E)
//   â‘¡ Walk through sorted edges one by one
//   â‘¢ For each edge (v, w): ask "are v and w already connected?"
//        YES (same component) â†’ skip  â€” adding it would create a cycle
//        NO  (different components) â†’ add edge to MST, merge components
//   â‘£ Stop as soon as MST has V-1 edges
//
// State after the first 3 accepted edges (out of 8 vertices):
//   Union-Find components: {0,7}, {2,3}, {1}  â†’ 5 separate components
//   MST so far: [ (0-7,0.16), (2-3,0.17), (1-7,0.19) ]
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">vector</span><span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;</span> <span class="fn">kruskalMST</span>(<span class="tp">WeightedGraph</span><span class="op">&amp;</span> G) {
    vector<span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;</span> mst;

    <span class="cm">// Step 1: collect all edges and SORT by weight</span>
    vector<span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;</span> edges <span class="op">=</span> G.<span class="fn">allEdges</span>();
    <span class="fn">sort</span>(edges.<span class="fn">begin</span>(), edges.<span class="fn">end</span>());   <span class="cm">// cheapest first</span>

    <span class="cm">// Step 2: Union-Find tracks which component each vertex is in</span>
    <span class="tp">UnionFind</span> uf(G.V);

    <span class="kw">for</span> (<span class="tp">Edge</span><span class="op">&amp;</span> e : edges) {
        <span class="tp">int</span> v <span class="op">=</span> e.<span class="fn">either</span>(), w <span class="op">=</span> e.<span class="fn">other</span>(v);

        <span class="cm">// If v and w are in DIFFERENT components, this edge won't create a cycle</span>
        <span class="kw">if</span> (uf.<span class="fn">find</span>(v) <span class="op">!=</span> uf.<span class="fn">find</span>(w)) {
            mst.<span class="fn">push_back</span>(e);      <span class="cm">// accept this edge</span>
            uf.<span class="fn">unite</span>(v, w);         <span class="cm">// merge the two components into one</span>
        }
        <span class="cm">// Otherwise: same component â†’ would create a cycle â†’ skip</span>

        <span class="kw">if</span> (mst.<span class="fn">size</span>() <span class="op">==</span> G.V <span class="op">-</span> <span class="nm">1</span>) <span class="kw">break</span>;  <span class="cm">// MST is complete: V-1 edges found</span>
    }
    <span class="kw">return</span> mst;
}</pre>
  </div>

  <h3>The Union-Find Data Structure</h3>
  <p>The magic behind Kruskal's efficiency is <strong>Union-Find</strong> (also called Disjoint Set Union). It answers one question incredibly fast: <em>"Are two vertices in the same connected component?"</em></p>

  <p>It maintains a forest of trees where each tree represents one component. Two operations:</p>
  <ul style="margin:0 0 16px 24px; color:#b8c2d4;">
    <li style="margin-bottom:8px;"><strong>find(x)</strong> â€” returns the "root" (representative) of x's component. If find(x) == find(y), they're connected.</li>
    <li style="margin-bottom:8px;"><strong>union(x, y)</strong> â€” merges the components containing x and y into one.</li>
  </ul>

  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">C++</span><span class="code-title">Union-Find with Path Compression + Union by Rank</span></div>
    <pre><span class="cm">// â”€â”€â”€ UNION-FIND (Disjoint Set Union) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each component is a tree.  parent[x] points toward the root.
// Root = representative of the component.  find(x) == find(y) â†” same component.
//
// TWO key optimizations that make it nearly O(1):
//
//  â‘  PATH COMPRESSION (halving):
//     Before:  x â†’ parent[x] â†’ grandparent â†’ ... â†’ root
//     After :  x â†’ grandparent â†’ ... â†’ root  (skip one level each call)
//     Effect : tree flattens over time
//
//  â‘¡ UNION BY RANK:
//     Always attach the SHORTER tree under the TALLER tree.
//     Prevents trees from growing tall (worst case depth = O(log N)).
//
// Together they give O(Î±(N)) per operation â€” effectively O(1).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">class</span> <span class="tp">UnionFind</span> {
    vector<span class="op">&lt;</span><span class="tp">int</span><span class="op">&gt;</span> parent, rank;
<span class="kw">public</span>:
    <span class="fn">UnionFind</span>(<span class="tp">int</span> n) : parent(n), rank(n, <span class="nm">0</span>) {
        <span class="kw">for</span> (<span class="tp">int</span> i <span class="op">=</span> <span class="nm">0</span>; i <span class="op">&lt;</span> n; i<span class="op">++</span>) parent[i] <span class="op">=</span> i;  <span class="cm">// each vertex is its own root</span>
    }

    <span class="cm">// Find root of x, with PATH COMPRESSION (halving)
    // Each call: x skips one level â†’ parent[x] = grandparent
    // Example: find(8) on chain 8â†’4â†’2â†’0  becomes  8â†’2â†’0 after one call</span>
    <span class="tp">int</span> <span class="fn">find</span>(<span class="tp">int</span> x) {
        <span class="kw">while</span> (parent[x] <span class="op">!=</span> x) {
            parent[x] <span class="op">=</span> parent[parent[x]];  <span class="cm">// SKIP a level: point to grandparent</span>
            x <span class="op">=</span> parent[x];
        }
        <span class="kw">return</span> x;
    }

    <span class="cm">// Merge components of x and y using UNION BY RANK
    // Rank â‰ˆ upper bound on tree height.
    // Attach shorter tree (lower rank) UNDER taller tree (higher rank)
    // to keep the combined tree as flat as possible.</span>
    <span class="kw">void</span> <span class="fn">unite</span>(<span class="tp">int</span> x, <span class="tp">int</span> y) {
        <span class="tp">int</span> rx <span class="op">=</span> <span class="fn">find</span>(x), ry <span class="op">=</span> <span class="fn">find</span>(y);
        <span class="kw">if</span> (rx <span class="op">==</span> ry) <span class="kw">return</span>;  <span class="cm">// already same component â€” nothing to do</span>

        <span class="kw">if</span>      (rank[rx] <span class="op">&lt;</span> rank[ry]) parent[rx] <span class="op">=</span> ry;  <span class="cm">// rx is shorter â†’ attach under ry</span>
        <span class="kw">else if</span> (rank[rx] <span class="op">&gt;</span> rank[ry]) parent[ry] <span class="op">=</span> rx;  <span class="cm">// ry is shorter â†’ attach under rx</span>
        <span class="kw">else</span> { parent[ry] <span class="op">=</span> rx; rank[rx]<span class="op">++</span>; }            <span class="cm">// equal height: pick rx, increase rank</span>
    }
};</pre>
  </div>

  <div class="key-insight">
    <div class="icon">âš¡</div>
    <p>With <strong>path compression</strong> + <strong>union by rank</strong>, each find/union takes essentially <em>constant</em> amortized time â€” O(Î±(N)) where Î± is the inverse Ackermann function, which is â‰¤ 5 for any realistic input. This makes Union-Find one of the most practically efficient data structures ever invented.</p>
  </div>

  <div class="callout success"><div class="ci"></div>
    <p><strong>ğŸ”‘ The Inverse Ackermann Function â€” Why it's "basically O(1)"</strong><br>
    Î±(N) is the inverse of the Ackermann function, which grows so astronomically fast that its inverse barely moves. For all practical purposes:<br>
    Î±(N) â‰¤ 4 for N â‰¤ 2<sup>65536</sup> (more atoms than the observable universe)<br>
    So "O(Î±(N))" really means "constant for every input you will ever see in your career." Kruskal's total cost is dominated entirely by the O(E log E) sort â€” Union-Find is essentially free.</p>
  </div>

  <h3>Full Trace: Kruskal's on 8 Vertices</h3>
  <p>Graph has 8 vertices (0â€“7) and 16 edges. We sort all edges by weight and process:</p>

  <div class="trace-container">
    <div class="trace-title">Step-by-Step Execution</div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num">1</div>
        <div class="step-title">Process edge (0â€“7, weight 0.16)</div>
      </div>
      <div class="step-body">find(0) = 0, find(7) = 7 â†’ different components<br>
      <span class="accepted">âœ“ Accept</span> â€” add to MST. Union(0, 7). Components: <code>{0,7}, {1}, {2}, {3}, {4}, {5}, {6}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num teal">2</div>
        <div class="step-title">Process edge (2â€“3, weight 0.17)</div>
      </div>
      <div class="step-body">find(2) = 2, find(3) = 3 â†’ different<br>
      <span class="accepted">âœ“ Accept</span> â€” Union(2,3). Components: <code>{0,7}, {1}, {2,3}, {4}, {5}, {6}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num violet">3</div>
        <div class="step-title">Process edge (1â€“7, weight 0.19)</div>
      </div>
      <div class="step-body">find(1) = 1, find(7) = 0 (7's root is 0, from step 1)<br>
      <span class="accepted">âœ“ Accept</span> â€” Union(1, 0). Components: <code>{0,1,7}, {2,3}, {4}, {5}, {6}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num green">4</div>
        <div class="step-title">Process edge (0â€“2, weight 0.26)</div>
      </div>
      <div class="step-body">find(0) = 0, find(2) = 2 â†’ different<br>
      <span class="accepted">âœ“ Accept</span> â€” Union(0, 2). Components: <code>{0,1,2,3,7}, {4}, {5}, {6}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num">5</div>
        <div class="step-title">Process edge (5â€“7, weight 0.28)</div>
      </div>
      <div class="step-body">find(5) = 5, find(7) = 0 â†’ different<br>
      <span class="accepted">âœ“ Accept</span> â€” Union(5, 0). Components: <code>{0,1,2,3,5,7}, {4}, {6}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num rose">6</div>
        <div class="step-title">Process edge (1â€“3, weight 0.29)</div>
      </div>
      <div class="step-body">find(1) = 0, find(3) = 0 â†’ <strong>same component!</strong><br>
      <span class="rejected">âœ— Reject</span> â€” would create a cycle inside <code>{0,1,2,3,5,7}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num teal">7</div>
        <div class="step-title">... skip (1â€“5, 2â€“7) â€” both create cycles ...</div>
      </div>
      <div class="step-body"><span class="rejected">âœ— Reject</span> all â€” same component</div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num green">8</div>
        <div class="step-title">Process edge (4â€“5, weight 0.35)</div>
      </div>
      <div class="step-body">find(4) = 4, find(5) = 0 â†’ different<br>
      <span class="accepted">âœ“ Accept</span> â€” Union(4, 0). Components: <code>{0,1,2,3,4,5,7}, {6}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header">
        <div class="step-num violet">9</div>
        <div class="step-title">Process edge (6â€“2, weight 0.40)</div>
      </div>
      <div class="step-body">find(6) = 6, find(2) = 0 â†’ different<br>
      <span class="accepted">âœ“ Accept</span> â€” Now all 8 vertices connected. <strong>MST complete!</strong> Total weight = 0.16+0.17+0.19+0.26+0.28+0.35+0.40 = <em>1.81</em></div>
    </div>
  </div>

  <h3>Time Complexity</h3>
  <p>Kruskal's has two phases: sorting and Union-Find operations.</p>
  <div class="complexity-bar-wrap">
    <div class="cbar-row">
      <div class="cbar-label">Sorting edges</div>
      <div class="cbar-track"><div class="cbar-fill medium">O(E log E)</div></div>
    </div>
    <div class="cbar-row">
      <div class="cbar-label">Union-Find ops</div>
      <div class="cbar-track"><div class="cbar-fill fast">O(E Â· Î±(V)) â‰ˆ O(E)</div></div>
    </div>
    <div class="cbar-row">
      <div class="cbar-label">Total</div>
      <div class="cbar-track"><div class="cbar-fill medium">O(E log E)</div></div>
    </div>
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART IV: PRIM -->
<section id="prim">
  <div class="section-label">Part IV</div>
  <h2>Prim's <span>Algorithm</span></h2>

  <div class="algo-card">
    <div class="algo-card-header">
      <div class="algo-icon" style="background:rgba(45,212,191,0.15);">ğŸŒ±</div>
      <div>
        <div style="font-family:Syne,sans-serif;font-size:1.1rem;font-weight:800;color:#e8edf5;">Prim's Algorithm (Eager Version)</div>
        <div style="font-size:.88rem;color:var(--text-dim);">Grow the MST one vertex at a time from a starting vertex</div>
      </div>
    </div>
    <div class="algo-card-body">
      <div class="stats-row">
        <div class="stat-pill"><span>Time</span><strong style="color:var(--gold);">O(E log V)</strong></div>
        <div class="stat-pill"><span>Space</span><strong style="color:var(--teal);">O(V)</strong></div>
        <div class="stat-pill"><span>Data Structure</span><strong style="color:var(--violet);">Indexed Min-PQ</strong></div>
        <div class="stat-pill"><span>Best For</span><strong style="color:var(--green);">Dense Graphs</strong></div>
      </div>
    </div>
  </div>

  <h3>The Core Idea</h3>
  <p>While Kruskal's algorithm thinks about edges globally, Prim's algorithm <strong>grows a tree outward from a single starting vertex</strong>. At every step, it picks the cheapest edge that connects a vertex already in the tree to a vertex not yet in the tree.</p>

  <div class="analogy">
    <div class="analogy-label">Analogy â€” Spreading a Campfire</div>
    <p>Imagine you light a campfire at one vertex. At each moment, the fire can spread to a neighboring vertex. Of all possible directions the fire could spread, it always chooses the cheapest edge. This "fire" grows until it has reached every vertex.</p>
  </div>

  <h3>Lazy vs. Eager: What's the Difference?</h3>
  <p>There are two versions of Prim's:</p>
  <ul style="margin:0 0 16px 24px; color:#b8c2d4;">
    <li style="margin-bottom:10px;"><strong>Lazy Prim's</strong> â€” Stores <em>all</em> crossing edges in a priority queue, including stale ones. When extracting, it checks if the edge still crosses the cut. Simple but uses O(E) space for the queue.</li>
    <li style="margin-bottom:10px;"><strong>Eager Prim's</strong> â€” For each non-tree vertex, stores only the <em>best</em> (cheapest) known edge connecting it to the tree. Uses O(V) space. Needs a special <em>indexed</em> priority queue that supports <code>decreaseKey</code>.</li>
  </ul>

  <h3>Eager Prim's Algorithm</h3>
  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">C++</span><span class="code-title">Eager Prim's â€” Indexed Min-Priority Queue</span></div>
    <pre><span class="cm">// â”€â”€â”€ PRIM'S ALGORITHM (EAGER VERSION) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Plain English:
//   â‘  Start with vertex 0 in the tree; distTo[0]=0, all others = âˆ
//   â‘¡ Use an IndexedMinPQ keyed by "cheapest edge weight to tree"
//   â‘¢ Each round: extract vertex v with cheapest connection to tree
//   â‘£ Mark v as in-tree; add edgeTo[v] to MST
//   â‘¤ Scan v's neighbors: if cheaper edge found, UPDATE distTo[w] and
//      decreaseKey(w) in the PQ (this is the "eager" part â€” we always
//      keep only the BEST known edge per non-tree vertex, not all candidates)
//
// distTo[w] = cheapest single edge weight connecting w to the tree SO FAR
// edgeTo[w] = the actual edge achieving that cheapest connection
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">vector</span><span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;</span> <span class="fn">primMST</span>(<span class="tp">WeightedGraph</span><span class="op">&amp;</span> G) {
    vector<span class="op">&lt;</span><span class="tp">bool</span><span class="op">&gt;</span>   marked(G.V, <span class="kw">false</span>);    <span class="cm">// is vertex in MST?</span>
    vector<span class="op">&lt;</span><span class="tp">double</span><span class="op">&gt;</span> distTo(G.V, INF);     <span class="cm">// cheapest edge weight to tree</span>
    vector<span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;</span>   edgeTo(G.V);          <span class="cm">// cheapest edge itself</span>
    vector<span class="op">&lt;</span><span class="tp">Edge</span><span class="op">&gt;</span>   mst;
    <span class="tp">IndexedMinPQ</span>   ipq(G.V);

    distTo[<span class="nm">0</span>] <span class="op">=</span> <span class="nm">0.0</span>;
    ipq.<span class="fn">insert</span>(<span class="nm">0</span>, <span class="nm">0.0</span>);              <span class="cm">// start from vertex 0</span>

    <span class="kw">while</span> (<span class="op">!</span>ipq.<span class="fn">empty</span>()) {
        <span class="tp">int</span> v <span class="op">=</span> ipq.<span class="fn">extractMin</span>();     <span class="cm">// vertex closest to tree</span>
        marked[v] <span class="op">=</span> <span class="kw">true</span>;
        <span class="kw">if</span> (v <span class="op">!=</span> <span class="nm">0</span>) mst.<span class="fn">push_back</span>(edgeTo[v]);  <span class="cm">// add its edge to MST</span>

        <span class="kw">for</span> (<span class="tp">Edge</span><span class="op">&amp;</span> e : G.adj[v]) {
            <span class="tp">int</span> w <span class="op">=</span> e.<span class="fn">other</span>(v);
            <span class="kw">if</span> (marked[w]) <span class="kw">continue</span>;          <span class="cm">// already in MST â€” skip</span>

            <span class="kw">if</span> (e.weight <span class="op">&lt;</span> distTo[w]) {
                distTo[w] <span class="op">=</span> e.weight;           <span class="cm">// found cheaper edge to w</span>
                edgeTo[w] <span class="op">=</span> e;                  <span class="cm">// update best edge to w</span>
                <span class="kw">if</span> (ipq.<span class="fn">contains</span>(w)) ipq.<span class="fn">decreaseKey</span>(w, e.weight);  <span class="cm">// update PQ</span>
                <span class="kw">else</span>                  ipq.<span class="fn">insert</span>(w, e.weight);        <span class="cm">// first time seeing w</span>
            }
        }
    }
    <span class="kw">return</span> mst;
}</pre>
  </div>

  <h3>The Indexed Priority Queue</h3>
  <p>Prim's eager version needs a special data structure: an <strong>indexed min-priority queue</strong>. This is like a normal priority queue but with a twist â€” you can update (decrease) the priority of an existing element efficiently.</p>

  <div class="definition">
    <div class="definition-label">Indexed Min-Priority Queue â€” Key Operations</div>
    <p><strong>insert(vertex, priority)</strong> â€” add a vertex with a given priority<br>
    <strong>extractMin()</strong> â€” remove and return the vertex with lowest priority<br>
    <strong>decreaseKey(vertex, newPriority)</strong> â€” update a vertex's priority (when we find a better edge)<br>
    <strong>contains(vertex)</strong> â€” check if vertex is in the queue<br><br>
    All operations: <em>O(log V)</em>. Implemented as a binary heap with a position-lookup array.</p>
  </div>

  <h3>Prim's Trace (Eager, same 8-vertex graph)</h3>

  <div class="trace-container">
    <div class="trace-title">Starting from vertex 0</div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num">1</div><div class="step-title">Extract vertex 0 (dist=0.0) â€” Start</div></div>
      <div class="step-body">No edge added (first vertex). Scan neighbors: 7(0.16), 2(0.26), 4(0.38), 6(0.58)<br>Insert all into IPQ â†’ <code>{7:0.16, 2:0.26, 4:0.38, 6:0.58}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num teal">2</div><div class="step-title">Extract vertex 7 (dist=0.16) â€” Best neighbor</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (0â€“7, 0.16) to MST.</span> Scan 7's neighbors:<br>
      Vertex 1: new! dist[1]=0.19. Vertex 5: new! dist[5]=0.28.<br>
      Vertex 4: 0.37 &lt; 0.38 â†’ <code>decreaseKey(4, 0.37)</code><br>
      IPQ: <code>{1:0.19, 2:0.26, 5:0.28, 4:0.37, 6:0.58}</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num violet">3</div><div class="step-title">Extract vertex 1 (dist=0.19)</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (1â€“7, 0.19) to MST.</span> Scan 1's neighbors:<br>
      Vertex 3: dist[3]=0.29. Vertex 5: 0.32 &gt; 0.28, no update.</div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num green">4</div><div class="step-title">Extract vertex 2 (dist=0.26)</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (0â€“2, 0.26) to MST.</span> Scan neighbors:<br>
      Vertex 3: 0.17 &lt; 0.29 â†’ <code>decreaseKey(3, 0.17)</code><br>
      Vertex 6: 0.40 &lt; 0.58 â†’ <code>decreaseKey(6, 0.40)</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num">5</div><div class="step-title">Extract vertex 3 (dist=0.17)</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (2â€“3, 0.17) to MST.</span> No better edges found from 3.</div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num teal">6</div><div class="step-title">Extract vertex 5 (dist=0.28)</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (5â€“7, 0.28) to MST.</span><br>
      Vertex 4: 0.35 &lt; 0.37 â†’ <code>decreaseKey(4, 0.35)</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num rose">7</div><div class="step-title">Extract vertex 4 (dist=0.35)</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (4â€“5, 0.35) to MST.</span> No improvements from 4.</div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num violet">8</div><div class="step-title">Extract vertex 6 (dist=0.40)</div></div>
      <div class="step-body"><span class="accepted">âœ“ Add edge (6â€“2, 0.40) to MST. Done!</span><br>
      Final MST weight = 1.81 â€” <em>identical to Kruskal's result</em></div>
    </div>
  </div>

  <div class="callout info"><div class="ci"></div><p>Kruskal's and Prim's always find the same MST (when weights are distinct), but in a different order. Kruskal's picked edges globally by weight; Prim's picked them locally by growing outward from vertex 0.</p></div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART V: DIJKSTRA -->
<section id="dijkstra">
  <div class="section-label">Part V</div>
  <h2>Dijkstra's <span>Algorithm</span></h2>

  <div class="algo-card">
    <div class="algo-card-header">
      <div class="algo-icon" style="background:rgba(96,165,250,0.15);">ğŸ—ºï¸</div>
      <div>
        <div style="font-family:Syne,sans-serif;font-size:1.1rem;font-weight:800;color:#e8edf5;">Dijkstra's Algorithm (1959)</div>
        <div style="font-size:.88rem;color:var(--text-dim);">Single-source shortest paths for graphs with non-negative weights</div>
      </div>
    </div>
    <div class="algo-card-body">
      <div class="stats-row">
        <div class="stat-pill"><span>Time</span><strong style="color:var(--gold);">O(E log V)</strong></div>
        <div class="stat-pill"><span>Space</span><strong style="color:var(--teal);">O(V)</strong></div>
        <div class="stat-pill"><span>Requirement</span><strong style="color:var(--rose);">Weights â‰¥ 0</strong></div>
        <div class="stat-pill"><span>Use Case</span><strong style="color:var(--green);">GPS, Routing</strong></div>
      </div>
    </div>
  </div>

  <h3>What Problem Does It Solve?</h3>
  <p>Given a directed weighted graph and a <strong>source vertex s</strong>, find the <em>shortest path</em> (minimum total weight) from s to <em>every other vertex</em>. "Shortest" means minimum total edge weight, not fewest edges.</p>

  <div class="analogy">
    <div class="analogy-label">Analogy â€” Ripples in a Pond</div>
    <p>Drop a stone at the source vertex. Ripples spread outward through the graph. The first ripple to reach a vertex gives the shortest distance. Dijkstra's algorithm processes vertices exactly in the order the ripples would reach them â€” nearest first.</p>
  </div>

  <h3>The Relaxation Operation</h3>
  <p>The core operation in all shortest-path algorithms is called <strong>relaxation</strong>. Given an edge from v to w, we ask: "Can I reach w more cheaply by going through v?"</p>

  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">C++</span><span class="code-title">Edge Relaxation â€” the fundamental operation</span></div>
    <pre><span class="cm">// â”€â”€â”€ EDGE RELAXATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// The single core operation in ALL shortest-path algorithms.
//
// Question: "Can I reach w more cheaply by going THROUGH v?"
//
// Concrete example:
//   distTo[v]=5, edge vâ†’w has weight=3, distTo[w]=âˆ
//   newDist = 5+3 = 8 < âˆ  â†’ RELAX! distTo[w] = 8, edgeTo[w] = this edge
//
//   Later: distTo[v]=5, edge vâ†’w has weight=3, distTo[w]=7 (already updated)
//   newDist = 5+3 = 8 > 7  â†’ no improvement, keep distTo[w]=7
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// distTo[v] = currently known shortest distance from source to v
// edgeTo[v] = last edge on the shortest known path to v</span>

<span class="kw">void</span> <span class="fn">relax</span>(<span class="tp">DirectedEdge</span> e) {
    <span class="tp">int</span>    v <span class="op">=</span> e.<span class="fn">from</span>(), w <span class="op">=</span> e.<span class="fn">to</span>();
    <span class="tp">double</span> newDist <span class="op">=</span> distTo[v] <span class="op">+</span> e.weight;

    <span class="kw">if</span> (newDist <span class="op">&lt;</span> distTo[w]) {        <span class="cm">// found a shorter path to w!</span>
        distTo[w] <span class="op">=</span> newDist;           <span class="cm">// update best known distance</span>
        edgeTo[w] <span class="op">=</span> e;                 <span class="cm">// remember which edge led here</span>
    }
}</pre>
  </div>

  <h3>Dijkstra's Algorithm</h3>
  <p>Dijkstra's algorithm is structurally very similar to eager Prim's. The key difference: <strong>Prim's tracks cheapest edge weight, Dijkstra's tracks total path distance from source</strong>.</p>

  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">C++</span><span class="code-title">Dijkstra's Algorithm â€” Single-Source Shortest Paths</span></div>
    <pre><span class="cm">// â”€â”€â”€ DIJKSTRA'S ALGORITHM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Plain English:
//   â‘  Initialize: distTo[source]=0, all others = âˆ
//   â‘¡ Insert source into IndexedMinPQ with priority 0
//   â‘¢ Repeat until PQ is empty:
//        a) Extract vertex v with SMALLEST distTo  ("settle" it)
//        b) Mark v as settled â€” its distance is now FINAL
//        c) For each edge vâ†’w: relax (if distTo[v]+weight < distTo[w],
//           update distTo[w] and decreaseKey(w) in PQ)
//
// KEY INVARIANT: Once a vertex is settled, distTo[v] is the true
//               shortest distance. This relies on weights â‰¥ 0!
//
// Contrast with Prim's:  priority = cheapest EDGE weight to v
// Here (Dijkstra's):     priority = total PATH distance from source to v
//
// distTo state progression (8-vertex graph, source=0):
//   After settle 0: [0, 5, âˆ, âˆ, 9, âˆ, âˆ, 8]
//   After settle 1: [0, 5, 17, 20, 9, âˆ, âˆ, 8]
//   After settle 7: [0, 5, 15, 20, 9, 14, âˆ, 8]
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">void</span> <span class="fn">dijkstra</span>(<span class="tp">WeightedDigraph</span><span class="op">&amp;</span> G, <span class="tp">int</span> s) {
    vector<span class="op">&lt;</span><span class="tp">double</span><span class="op">&gt;</span>       distTo(G.V, INF);      <span class="cm">// shortest known dist from s</span>
    vector<span class="op">&lt;</span><span class="tp">DirectedEdge</span><span class="op">&gt;</span> edgeTo(G.V);           <span class="cm">// last edge on shortest path</span>
    vector<span class="op">&lt;</span><span class="tp">bool</span><span class="op">&gt;</span>         settled(G.V, <span class="kw">false</span>);   <span class="cm">// finalized vertices</span>
    <span class="tp">IndexedMinPQ</span>          ipq(G.V);

    distTo[s] <span class="op">=</span> <span class="nm">0.0</span>;
    ipq.<span class="fn">insert</span>(s, <span class="nm">0.0</span>);

    <span class="kw">while</span> (<span class="op">!</span>ipq.<span class="fn">empty</span>()) {
        <span class="tp">int</span> v <span class="op">=</span> ipq.<span class="fn">extractMin</span>();    <span class="cm">// settle the nearest unsettled vertex</span>
        settled[v] <span class="op">=</span> <span class="kw">true</span>;

        <span class="kw">for</span> (<span class="tp">DirectedEdge</span><span class="op">&amp;</span> e : G.adj[v]) {
            <span class="tp">int</span>    w      <span class="op">=</span> e.<span class="fn">to</span>();
            <span class="tp">double</span> newDist <span class="op">=</span> distTo[v] <span class="op">+</span> e.weight;

            <span class="kw">if</span> (settled[w]) <span class="kw">continue</span>;  <span class="cm">// already finalized â€” skip</span>

            <span class="kw">if</span> (newDist <span class="op">&lt;</span> distTo[w]) {   <span class="cm">// relaxation â€” found shorter path!</span>
                distTo[w] <span class="op">=</span> newDist;
                edgeTo[w] <span class="op">=</span> e;
                <span class="kw">if</span> (ipq.<span class="fn">contains</span>(w)) ipq.<span class="fn">decreaseKey</span>(w, newDist);
                <span class="kw">else</span>                  ipq.<span class="fn">insert</span>(w, newDist);
            }
        }
    }
}

<span class="cm">// Reconstruct actual path to target t by following edgeTo[] backward:
//   e.g., to reconstruct path to vertex 3 after 8-vertex trace:
//   edgeTo[3] = 2â†’3, edgeTo[2] = 5â†’2, edgeTo[5] = 4â†’5, edgeTo[4] = 0â†’4
//   Walk backward: 3â†2â†5â†4â†0 â†’ push onto stack â†’ pop for 0â†’4â†’5â†’2â†’3</span>
<span class="kw">vector</span><span class="op">&lt;</span><span class="tp">DirectedEdge</span><span class="op">&gt;</span> <span class="fn">pathTo</span>(<span class="tp">int</span> t) {
    stack<span class="op">&lt;</span><span class="tp">DirectedEdge</span><span class="op">&gt;</span> path;
    <span class="kw">for</span> (<span class="tp">DirectedEdge</span> e <span class="op">=</span> edgeTo[t]; e <span class="op">!=</span> <span class="kw">null</span>; e <span class="op">=</span> edgeTo[e.<span class="fn">from</span>()])
        path.<span class="fn">push</span>(e);        <span class="cm">// push edges from t backward to source</span>
    <span class="cm">// pop the stack to get edges in forward order: source â†’ ... â†’ t</span>
    <span class="kw">return</span> {path.<span class="fn">rbegin</span>(), path.<span class="fn">rend</span>()};
}</pre>
  </div>

  <h3>Full Trace: Dijkstra's on 8 Vertices</h3>
  <p>Directed graph, source = vertex 0. Track how <code>distTo[]</code> evolves:</p>

  <div class="trace-container">
    <div class="trace-title">Extracting vertices nearest-first</div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num">1</div><div class="step-title">Extract vertex 0 (dist=0.0) â€” Source</div></div>
      <div class="step-body">
        Relax 0â†’1: <code>distTo[1] = 5.0</code><br>
        Relax 0â†’4: <code>distTo[4] = 9.0</code><br>
        Relax 0â†’7: <code>distTo[7] = 8.0</code><br>
        IPQ: <code>{1:5.0, 7:8.0, 4:9.0}</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num teal">2</div><div class="step-title">Extract vertex 1 (dist=5.0)</div></div>
      <div class="step-body">
        Relax 1â†’2: <code>distTo[2] = 17.0</code><br>
        Relax 1â†’3: <code>distTo[3] = 20.0</code><br>
        Relax 1â†’7: 5+4=9 &gt; 8 â€” no update<br>
        distTo: <code>[0, 5, 17, 20, 9, âˆ, âˆ, 8]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num violet">3</div><div class="step-title">Extract vertex 7 (dist=8.0)</div></div>
      <div class="step-body">
        Relax 7â†’5: <code>distTo[5] = 14.0</code><br>
        Relax 7â†’2: 8+7=15 &lt; 17 â†’ <code>decreaseKey(2, 15.0)</code><br>
        distTo: <code>[0, 5, 15, 20, 9, 14, âˆ, 8]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num green">4</div><div class="step-title">Extract vertex 4 (dist=9.0)</div></div>
      <div class="step-body">
        Relax 4â†’5: 9+4=13 &lt; 14 â†’ <code>decreaseKey(5, 13.0)</code><br>
        Relax 4â†’6: <code>distTo[6] = 29.0</code><br>
        distTo: <code>[0, 5, 15, 20, 9, 13, 29, 8]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num">5</div><div class="step-title">Extract vertex 5 (dist=13.0)</div></div>
      <div class="step-body">
        Relax 5â†’2: 13+1=14 &lt; 15 â†’ <code>decreaseKey(2, 14.0)</code><br>
        Relax 5â†’6: 13+13=26 &lt; 29 â†’ <code>decreaseKey(6, 26.0)</code><br>
        distTo: <code>[0, 5, 14, 20, 9, 13, 26, 8]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num teal">6</div><div class="step-title">Extract vertex 2 (dist=14.0)</div></div>
      <div class="step-body">
        Relax 2â†’3: 14+3=17 &lt; 20 â†’ <code>decreaseKey(3, 17.0)</code><br>
        Relax 2â†’6: 14+11=25 &lt; 26 â†’ <code>decreaseKey(6, 25.0)</code><br>
        distTo: <code>[0, 5, 14, 17, 9, 13, 25, 8]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num rose">7</div><div class="step-title">Extract vertex 3 (dist=17.0)</div></div>
      <div class="step-body">
        Relax 3â†’6: 17+9=26 &gt; 25 â€” no update
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num violet">8</div><div class="step-title">Extract vertex 6 (dist=25.0) â€” Done!</div></div>
      <div class="step-body">
        No outgoing edges. Final distances: <code>[0.0, 5.0, 14.0, 17.0, 9.0, 13.0, 25.0, 8.0]</code>
      </div>
    </div>
  </div>

  <h4>Shortest-Path Tree (edgeTo reconstruction)</h4>
  <div class="compare-table-wrap">
    <table>
      <tr><th>Target Vertex</th><th>Last Edge</th><th>Full Path from 0</th><th>Distance</th></tr>
      <tr><td>1</td><td><code>0â†’1</code></td><td>0 â†’ 1</td><td><span class="tag tag-gold">5.0</span></td></tr>
      <tr><td>2</td><td><code>5â†’2</code></td><td>0 â†’ 4 â†’ 5 â†’ 2</td><td><span class="tag tag-teal">14.0</span></td></tr>
      <tr><td>3</td><td><code>2â†’3</code></td><td>0 â†’ 4 â†’ 5 â†’ 2 â†’ 3</td><td><span class="tag tag-violet">17.0</span></td></tr>
      <tr><td>4</td><td><code>0â†’4</code></td><td>0 â†’ 4</td><td><span class="tag tag-gold">9.0</span></td></tr>
      <tr><td>5</td><td><code>4â†’5</code></td><td>0 â†’ 4 â†’ 5</td><td><span class="tag tag-teal">13.0</span></td></tr>
      <tr><td>6</td><td><code>2â†’6</code></td><td>0 â†’ 4 â†’ 5 â†’ 2 â†’ 6</td><td><span class="tag tag-violet">25.0</span></td></tr>
      <tr><td>7</td><td><code>0â†’7</code></td><td>0 â†’ 7</td><td><span class="tag tag-gold">8.0</span></td></tr>
    </table>
  </div>

  <h3>Why Correctness Requires Non-Negative Weights</h3>
  <p>Dijkstra's correctness proof relies on one key assumption: <strong>once a vertex is settled (extracted from the priority queue), its distance is final.</strong> This is guaranteed only if all future edges have non-negative weight.</p>

  <div class="callout warn"><div class="ci"></div>
    <p><strong>Negative edge example:</strong> Vertices S, A, B. Edges: Sâ†’A (1), Sâ†’B (5), Aâ†’B (âˆ’10).<br>
    Dijkstra settles B with distance 5 before discovering the shorter path Sâ†’Aâ†’B = 1+(âˆ’10) = âˆ’9. With negative edges, "nearest vertex" is no longer safe to finalize â€” a future negative edge could always create a shorter path.</p>
  </div>

  <div class="callout info"><div class="ci"></div>
    <p><strong>ğŸ—ï¸ Prim's vs Dijkstra's â€” One Variable Apart</strong><br>
    These two algorithms share the exact same skeleton. The only difference is what value they store as the priority in the indexed min-PQ:<br><br>
    <code>Prim's:     priority = e.weight</code>  â† cheapest SINGLE edge to tree<br>
    <code>Dijkstra's: priority = distTo[v] + e.weight</code>  â† total PATH cost from source<br><br>
    Prim's cares about the cheapest edge per step (builds MST).
    Dijkstra's cares about cheapest total path (builds shortest-path tree).
    Same data structure, same loop, one changed line.</p>
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART VI: BELLMAN-FORD -->
<section id="bellman">
  <div class="section-label">Part VI</div>
  <h2>Bellman-<span>Ford</span> Algorithm</h2>

  <div class="algo-card">
    <div class="algo-card-header">
      <div class="algo-icon" style="background:rgba(251,113,133,0.15);">âš¡</div>
      <div>
        <div style="font-family:Syne,sans-serif;font-size:1.1rem;font-weight:800;color:#e8edf5;">Bellman-Ford Algorithm (1958)</div>
        <div style="font-size:.88rem;color:var(--text-dim);">Shortest paths with negative weights + negative cycle detection</div>
      </div>
    </div>
    <div class="algo-card-body">
      <div class="stats-row">
        <div class="stat-pill"><span>Time</span><strong style="color:var(--rose);">O(VE)</strong></div>
        <div class="stat-pill"><span>Space</span><strong style="color:var(--teal);">O(V)</strong></div>
        <div class="stat-pill"><span>Handles</span><strong style="color:var(--green);">Negative Weights</strong></div>
        <div class="stat-pill"><span>Detects</span><strong style="color:var(--violet);">Negative Cycles</strong></div>
      </div>
    </div>
  </div>

  <h3>The Core Idea</h3>
  <p>Bellman-Ford is beautifully simple, if less elegant than Dijkstra's: <strong>relax every single edge, and repeat this Vâˆ’1 times</strong>. After Vâˆ’1 rounds, all shortest paths are guaranteed to be correct â€” as long as there are no negative cycles.</p>

  <div class="analogy">
    <div class="analogy-label">Analogy â€” Rumor Spreading</div>
    <p>Imagine shortest-path information as a rumor. In each "round," every person passes their best-known distance info to their neighbors. After Vâˆ’1 rounds, the information has had time to travel along any path of length up to Vâˆ’1, covering all possible shortest paths.</p>
  </div>

  <h3>Why Vâˆ’1 Passes?</h3>
  <p>A shortest path in a graph with V vertices visits at most V vertices â€” meaning at most <strong>Vâˆ’1 edges</strong>. In pass 1, we correctly settle all 1-edge paths. In pass 2, all 2-edge paths. After Vâˆ’1 passes, all paths are correct.</p>

  <div class="code-wrap">
    <div class="code-header"><span class="code-lang">C++</span><span class="code-title">Bellman-Ford with Negative Cycle Detection</span></div>
    <pre><span class="cm">// â”€â”€â”€ BELLMAN-FORD ALGORITHM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Plain English:
//   â‘  Initialize: distTo[source]=0, all others = âˆ
//   â‘¡ Repeat V-1 times:
//        Relax EVERY edge in the graph
//        If any distTo improved, set anyChange=true
//        If NO edge improved (anyChange=false), we've converged early â€” stop
//   â‘¢ Do ONE more pass (the Vth pass):
//        If any edge STILL relaxes â†’ a negative cycle exists â†’ return false
//        Otherwise â†’ distTo[] is correct â†’ return true
//
// WHY V-1 passes?
//   Any shortest path visits at most V vertices â†’ at most V-1 edges.
//   Pass k correctly solves all paths using â‰¤ k edges.
//   After V-1 passes, all possible path lengths are covered.
//
// State evolution (5-vertex graph, source=0):
//   Initial: [0, âˆ, âˆ, âˆ, âˆ]
//   Pass 1:  [0, 6, 4, 7, 2]   â† 1-edge paths found + negative shortcuts
//   Pass 2:  [0, 2, 4, 7, 2]   â† 2â†’1 negative edge improves dist[1]
//   Pass 3:  [0, 2, 4, 7, -2]  â† 1â†’4 negative improves dist[4]
//   Pass 4:  [0, 2, 4, 7, -2]  â† no changes â†’ converged!
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
<span class="kw">bool</span> <span class="fn">bellmanFord</span>(<span class="tp">WeightedDigraph</span><span class="op">&amp;</span> G, <span class="tp">int</span> s,
                  vector<span class="op">&lt;</span><span class="tp">double</span><span class="op">&gt;&amp;</span> distTo, vector<span class="op">&lt;</span><span class="tp">DirectedEdge</span><span class="op">&gt;&amp;</span> edgeTo) {
    distTo.<span class="fn">assign</span>(G.V, INF);
    distTo[s] <span class="op">=</span> <span class="nm">0.0</span>;

    <span class="cm">// MAIN LOOP: V-1 passes, each relaxes ALL edges</span>
    <span class="kw">for</span> (<span class="tp">int</span> pass <span class="op">=</span> <span class="nm">1</span>; pass <span class="op">&lt;=</span> G.V <span class="op">-</span> <span class="nm">1</span>; pass<span class="op">++</span>) {
        <span class="tp">bool</span> anyChange <span class="op">=</span> <span class="kw">false</span>;
        <span class="kw">for</span> (<span class="tp">DirectedEdge</span><span class="op">&amp;</span> e : G.<span class="fn">allEdges</span>()) {
            <span class="tp">int</span> v <span class="op">=</span> e.<span class="fn">from</span>(), w <span class="op">=</span> e.<span class="fn">to</span>();
            <span class="kw">if</span> (distTo[v] <span class="op">+</span> e.weight <span class="op">&lt;</span> distTo[w]) {
                distTo[w] <span class="op">=</span> distTo[v] <span class="op">+</span> e.weight;
                edgeTo[w] <span class="op">=</span> e;
                anyChange <span class="op">=</span> <span class="kw">true</span>;
            }
        }
        <span class="kw">if</span> (<span class="op">!</span>anyChange) <span class="kw">break</span>;    <span class="cm">// early termination: already converged</span>
    }

    <span class="cm">// NEGATIVE CYCLE CHECK (the Vth pass):
    // If distances had truly converged, no edge should relax on this extra pass.
    // If ANY edge still relaxes â†’ we're stuck in a negative cycle (infinite improvement)!</span>
    <span class="kw">for</span> (<span class="tp">DirectedEdge</span><span class="op">&amp;</span> e : G.<span class="fn">allEdges</span>()) {
        <span class="kw">if</span> (distTo[e.<span class="fn">from</span>()] <span class="op">+</span> e.weight <span class="op">&lt;</span> distTo[e.<span class="fn">to</span>()]) {
            <span class="kw">return false</span>;  <span class="cm">// negative cycle detected!</span>
        }
    }
    <span class="kw">return true</span>;  <span class="cm">// no negative cycle â€” distTo[] holds correct shortest distances</span>
}</pre>
  </div>

  <h3>What Is a Negative Cycle?</h3>
  <div class="definition">
    <div class="definition-label">Definition â€” Negative Cycle</div>
    <p>A <strong>negative cycle</strong> is a directed cycle whose total edge weight is <em>negative</em>. If one is reachable from the source, shortest paths become undefined â€” you could always go around the cycle one more time to make the distance smaller, with no bound.</p>
  </div>

  <h3>Trace: Bellman-Ford on 5 Vertices</h3>
  <p>Directed graph with negative edges (but no negative cycle). Source = vertex 0:</p>

  <div class="graph-card">
    <div class="graph-card-title">Edge List (includes negative weights)</div>
    <div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">
      <span class="tag tag-blue">0â†’1 (+6)</span>
      <span class="tag tag-blue">0â†’3 (+7)</span>
      <span class="tag tag-teal">1â†’2 (+5)</span>
      <span class="tag tag-teal">1â†’4 (-4)</span>
      <span class="tag tag-rose">2â†’1 (-2)</span>
      <span class="tag tag-rose">3â†’2 (-3)</span>
      <span class="tag tag-gold">3â†’4 (+9)</span>
      <span class="tag tag-violet">4â†’0 (+2)</span>
    </div>
  </div>

  <div class="trace-container">
    <div class="trace-title">Pass-by-Pass Evolution of distTo[]</div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num">0</div><div class="step-title">Initial State</div></div>
      <div class="step-body"><code>distTo = [0, âˆ, âˆ, âˆ, âˆ]</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num teal">1</div><div class="step-title">Pass 1 â€” All 1-edge paths settled</div></div>
      <div class="step-body">
        0â†’1: dist[1]=6 &nbsp;|&nbsp; 0â†’3: dist[3]=7 &nbsp;|&nbsp; 1â†’2: dist[2]=11 &nbsp;|&nbsp; 1â†’4: dist[4]=2<br>
        3â†’2: 7+(âˆ’3)=4 &lt; 11 â†’ dist[2]=<strong>4</strong><br>
        <code>After: [0, 6, 4, 7, 2]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num violet">2</div><div class="step-title">Pass 2 â€” 2-edge paths improve</div></div>
      <div class="step-body">
        2â†’1: 4+(âˆ’2)=2 &lt; 6 â†’ dist[1]=<strong>2</strong><br>
        <code>After: [0, 2, 4, 7, 2]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num green">3</div><div class="step-title">Pass 3 â€” 3-edge paths improve</div></div>
      <div class="step-body">
        1â†’4: 2+(âˆ’4)=âˆ’2 &lt; 2 â†’ dist[4]=<strong>âˆ’2</strong><br>
        <code>After: [0, 2, 4, 7, âˆ’2]</code>
      </div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num rose">4</div><div class="step-title">Pass 4 (final) â€” No changes</div></div>
      <div class="step-body">No edge improves. Converged!<br>
        <code>Final: [0, 2, 4, 7, âˆ’2]</code></div>
    </div>

    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num" style="background:#546e7a;">âœ“</div><div class="step-title">Negative Cycle Check (Pass 5) â€” No relaxations â†’ No negative cycle</div></div>
      <div class="step-body">All distances are correct. Shortest paths: 0â†’1=2, 0â†’2=4, 0â†’3=7, 0â†’4=âˆ’2</div>
    </div>
  </div>

  <h3>Real-World Application: Arbitrage Detection</h3>
  <div class="key-insight">
    <div class="icon">ğŸ’±</div>
    <p>In currency exchange, if you convert USD â†’ EUR â†’ JPY â†’ USD and end up with <em>more</em> dollars than you started, that's an arbitrage opportunity. Model exchange rates as edge weights using logarithms: log(rate). Now detecting a "profit cycle" = detecting a negative cycle. Bellman-Ford finds it!</p>
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART VII: COMPARISON -->
<section id="compare">
  <div class="section-label">Part VII</div>
  <h2>Algorithm <span>Comparison</span></h2>

  <div class="callout info"><div class="ci"></div>
    <p><strong>ğŸŒ³ All Four Algorithms Share the Same DNA</strong><br>
    Every algorithm in this lecture is a variation of one idea: maintain a set of "known-good" vertices/edges and greedily extend it using a priority queue or repeated relaxation.<br><br>
    <strong>Same skeleton, different priority:</strong><br>
    â€¢ Kruskal's: priority = edge weight; cycle check via Union-Find<br>
    â€¢ Prim's: priority = cheapest single edge weight connecting v to tree<br>
    â€¢ Dijkstra's: priority = total path cost from source to v<br>
    â€¢ Bellman-Ford: NO priority â€” brute-force relax all edges V-1 times<br><br>
    The last three all use <code>edgeTo[]</code> and can reconstruct paths by following parent links backward. Bellman-Ford's brute-force approach is the only one that catches negative cycles.</p>
  </div>

  <h3>The Big Four</h3>
  <div class="compare-table-wrap">
    <table>
      <tr>
        <th>Algorithm</th>
        <th>Problem</th>
        <th>Graph Type</th>
        <th>Negative Weights?</th>
        <th>Time</th>
        <th>Core Data Structure</th>
      </tr>
      <tr>
        <td><strong>Kruskal's</strong></td>
        <td><span class="tag tag-teal">MST</span></td>
        <td>Undirected</td>
        <td><span class="tag tag-gold">N/A</span></td>
        <td><code>O(E log E)</code></td>
        <td>Union-Find</td>
      </tr>
      <tr>
        <td><strong>Prim's (Eager)</strong></td>
        <td><span class="tag tag-teal">MST</span></td>
        <td>Undirected</td>
        <td><span class="tag tag-gold">N/A</span></td>
        <td><code>O(E log V)</code></td>
        <td>Indexed Min-PQ</td>
      </tr>
      <tr>
        <td><strong>Dijkstra's</strong></td>
        <td><span class="tag tag-blue">SSSP</span></td>
        <td>Directed</td>
        <td><span class="tag tag-rose">No</span></td>
        <td><code>O(E log V)</code></td>
        <td>Indexed Min-PQ</td>
      </tr>
      <tr>
        <td><strong>Bellman-Ford</strong></td>
        <td><span class="tag tag-blue">SSSP</span></td>
        <td>Directed</td>
        <td><span class="tag tag-green">Yes + detects cycles</span></td>
        <td><code>O(VE)</code></td>
        <td>Arrays only</td>
      </tr>
    </table>
  </div>

  <h3>Speed Comparison (larger = slower)</h3>
  <div class="complexity-bar-wrap">
    <div class="cbar-row">
      <div class="cbar-label">Dijkstra's</div>
      <div class="cbar-track"><div class="cbar-fill fast">O(E log V)</div></div>
    </div>
    <div class="cbar-row">
      <div class="cbar-label">Prim's (Eager)</div>
      <div class="cbar-track"><div class="cbar-fill fast">O(E log V)</div></div>
    </div>
    <div class="cbar-row">
      <div class="cbar-label">Kruskal's</div>
      <div class="cbar-track"><div class="cbar-fill medium">O(E log E)</div></div>
    </div>
    <div class="cbar-row">
      <div class="cbar-label">Bellman-Ford</div>
      <div class="cbar-track"><div class="cbar-fill slow">O(VE)</div></div>
    </div>
  </div>

  <h3>The Deep Structural Parallel: Prim's â‰ˆ Dijkstra's</h3>
  <p>Prim's and Dijkstra's look nearly identical in code. The only difference is what gets stored as the priority in the queue:</p>

  <div class="compare-table-wrap">
    <table>
      <tr><th></th><th>Prim's Algorithm</th><th>Dijkstra's Algorithm</th></tr>
      <tr>
        <td><strong>Priority of vertex v</strong></td>
        <td>Weight of the <em>cheapest edge</em> from tree to v</td>
        <td><em>Total distance</em> from source to v</td>
      </tr>
      <tr>
        <td><strong>Result</strong></td>
        <td>Minimum Spanning Tree (minimum total edge weight)</td>
        <td>Shortest Path Tree (minimum path distance from source)</td>
      </tr>
      <tr>
        <td><strong>Goal</strong></td>
        <td>Connect all vertices cheaply</td>
        <td>Reach all vertices quickly from source</td>
      </tr>
    </table>
  </div>

  <h3>Decision Guide: Which Algorithm to Use?</h3>

  <div class="trace-container">
    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num" style="font-size:16px;">?</div><div class="step-title">Do you need to connect all vertices with minimum total cost?</div></div>
      <div class="step-body">â†’ Use <strong>Kruskal's</strong> (sparse graphs, edge lists, or pre-sorted edges)<br>â†’ Use <strong>Prim's Eager</strong> (dense graphs, adjacency lists, starting from a specific vertex)</div>
    </div>
    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num teal" style="font-size:16px;">?</div><div class="step-title">Do you need shortest paths from one source, all weights â‰¥ 0?</div></div>
      <div class="step-body">â†’ Use <strong>Dijkstra's Algorithm</strong>. Fastest practical option for this case.</div>
    </div>
    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num rose" style="font-size:16px;">?</div><div class="step-title">Do edges have negative weights, or do you need to detect negative cycles?</div></div>
      <div class="step-body">â†’ Use <strong>Bellman-Ford</strong>. Slower (O(VE)) but handles any weight. Also detects negative cycles.</div>
    </div>
    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num violet" style="font-size:16px;">?</div><div class="step-title">Is the graph a DAG (Directed Acyclic Graph)?</div></div>
      <div class="step-body">â†’ Use <strong>Topological sort + relaxation</strong> in O(V+E), regardless of negative weights!</div>
    </div>
    <div class="trace-step">
      <div class="trace-step-header"><div class="step-num green" style="font-size:16px;">?</div><div class="step-title">Need shortest paths between ALL pairs of vertices?</div></div>
      <div class="step-body">â†’ Run Dijkstra from every vertex: O(VE log V) for non-negative weights<br>â†’ Or use <strong>Floyd-Warshall</strong>: O(VÂ³) for general weights</div>
    </div>
  </div>

  <h3>Key Theorems Summary</h3>
  <div class="compare-table-wrap">
    <table>
      <tr><th>Theorem</th><th>Statement</th></tr>
      <tr><td><strong>Cut Property</strong></td><td>The minimum-weight edge crossing any cut belongs to every MST.</td></tr>
      <tr><td><strong>Cycle Property</strong></td><td>The maximum-weight edge in any cycle belongs to no MST.</td></tr>
      <tr><td><strong>MST Uniqueness</strong></td><td>When all edge weights are distinct, the MST is unique.</td></tr>
      <tr><td><strong>Dijkstra Correctness</strong></td><td>Dijkstra's correctly solves SSSP iff all edge weights â‰¥ 0.</td></tr>
      <tr><td><strong>Bellman-Ford Sufficiency</strong></td><td>Vâˆ’1 passes suffice when no negative cycle is reachable from source.</td></tr>
      <tr><td><strong>Negative Cycle Detection</strong></td><td>If the V-th pass of Bellman-Ford relaxes any edge, a negative cycle exists.</td></tr>
      <tr><td><strong>Union-Find Performance</strong></td><td>With path compression + union by rank: O(Î±(N)) per operation â‰ˆ O(1).</td></tr>
    </table>
  </div>
</section>

</main>

<footer>
  Lecture 11 of 12 &nbsp;Â·&nbsp; Data Structures &amp; Algorithms &nbsp;Â·&nbsp; Based on Sedgewick &amp; Wayne, Algorithms 4th Ed.
</footer>

<script>
  // Animate complexity bars on scroll
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        e.target.querySelectorAll('.cbar-fill').forEach(bar => {
          bar.style.opacity = '1';
        });
      }
    });
  }, { threshold: 0.2 });

  document.querySelectorAll('.complexity-bar-wrap').forEach(el => observer.observe(el));

  // Fade in sections on scroll
  const sectionObs = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        e.target.style.opacity = '1';
        e.target.style.transform = 'translateY(0)';
      }
    });
  }, { threshold: 0.05 });

  document.querySelectorAll('section').forEach((el, i) => {
    el.style.opacity = '0';
    el.style.transform = 'translateY(30px)';
    el.style.transition = `opacity .6s ease ${i * 0.05}s, transform .6s ease ${i * 0.05}s`;
    sectionObs.observe(el);
  });
</script>
</body>
</html>
