<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Fundamentals & Depth-First Search</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=JetBrains+Mono:wght@400;600;700&family=Nunito:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0d1117;
    --bg2: #161b22;
    --bg3: #1c2330;
    --surface: #21262d;
    --border: #30363d;
    --text: #e6edf3;
    --muted: #8b949e;
    --teal: #39d0d8;
    --teal-dim: #1a6b70;
    --amber: #f0a830;
    --coral: #ff6b6b;
    --violet: #a78bfa;
    --green: #3fb950;
    --pink: #f778ba;
    --blue: #58a6ff;
    --code-bg: #161b22;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  html { scroll-behavior: smooth; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    font-size: 17px;
    line-height: 1.8;
    overflow-x: hidden;
  }

  /* â”€â”€ NOISE TEXTURE â”€â”€ */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 1000;
    opacity: 0.35;
  }

  /* â”€â”€ HERO â”€â”€ */
  .hero {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 4rem 2rem;
    position: relative;
    overflow: hidden;
  }

  .hero-bg {
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse 80% 60% at 50% 40%, #0e3a4a 0%, transparent 70%),
                radial-gradient(ellipse 50% 40% at 80% 80%, #1a1040 0%, transparent 60%),
                var(--bg);
  }

  .hero-graph {
    position: absolute;
    inset: 0;
    opacity: 0.12;
  }

  .hero-content { position: relative; z-index: 1; max-width: 900px; }

  .lecture-tag {
    display: inline-block;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    letter-spacing: 0.15em;
    color: var(--teal);
    border: 1px solid var(--teal-dim);
    padding: 0.35rem 1rem;
    border-radius: 2rem;
    margin-bottom: 2rem;
    animation: fadeSlideIn 0.8s ease both;
  }

  h1.hero-title {
    font-family: 'DM Serif Display', serif;
    font-size: clamp(2.8rem, 7vw, 5.5rem);
    line-height: 1.1;
    margin-bottom: 1.5rem;
    animation: fadeSlideIn 0.8s 0.15s ease both;
  }

  .hero-title span.accent { color: var(--teal); }
  .hero-title span.accent2 { color: var(--amber); }

  .hero-sub {
    font-size: 1.15rem;
    color: var(--muted);
    max-width: 600px;
    margin: 0 auto 3rem;
    animation: fadeSlideIn 0.8s 0.3s ease both;
  }

  .hero-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    justify-content: center;
    animation: fadeSlideIn 0.8s 0.45s ease both;
  }

  .pill {
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 0.4rem 1.1rem;
    border-radius: 2rem;
    font-size: 0.85rem;
    color: var(--muted);
  }

  @keyframes fadeSlideIn {
    from { opacity: 0; transform: translateY(24px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* â”€â”€ NAV â”€â”€ */
  .toc {
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(13,17,23,0.9);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    padding: 0.75rem 2rem;
    display: flex;
    gap: 0.5rem;
    overflow-x: auto;
    scrollbar-width: none;
  }
  .toc::-webkit-scrollbar { display: none; }
  .toc a {
    white-space: nowrap;
    font-size: 0.8rem;
    font-family: 'JetBrains Mono', monospace;
    color: var(--muted);
    text-decoration: none;
    padding: 0.35rem 0.75rem;
    border-radius: 0.4rem;
    transition: all 0.2s;
    border: 1px solid transparent;
  }
  .toc a:hover { color: var(--teal); border-color: var(--teal-dim); }

  /* â”€â”€ LAYOUT â”€â”€ */
  .container { max-width: 1100px; margin: 0 auto; padding: 0 2rem; }

  section { padding: 5rem 0; border-bottom: 1px solid var(--border); }

  /* â”€â”€ SECTION HEADERS â”€â”€ */
  .section-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--teal);
    letter-spacing: 0.12em;
    margin-bottom: 0.5rem;
    display: block;
  }

  h2.section-title {
    font-family: 'DM Serif Display', serif;
    font-size: clamp(2rem, 4vw, 3rem);
    line-height: 1.15;
    margin-bottom: 1rem;
  }

  h3 {
    font-family: 'DM Serif Display', serif;
    font-size: 1.5rem;
    margin: 2.5rem 0 1rem;
    color: var(--amber);
  }

  h4 {
    font-size: 1rem;
    font-weight: 800;
    color: var(--teal);
    margin: 1.5rem 0 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  p { margin-bottom: 1.2rem; color: #c9d1d9; }

  /* â”€â”€ CALLOUT BOXES â”€â”€ */
  .callout {
    border-left: 3px solid var(--teal);
    background: rgba(57,208,216,0.06);
    padding: 1.25rem 1.5rem;
    border-radius: 0 0.75rem 0.75rem 0;
    margin: 1.5rem 0;
  }
  .callout.amber { border-color: var(--amber); background: rgba(240,168,48,0.06); }
  .callout.coral { border-color: var(--coral); background: rgba(255,107,107,0.06); }
  .callout.violet { border-color: var(--violet); background: rgba(167,139,250,0.06); }
  .callout.green { border-color: var(--green); background: rgba(63,185,80,0.06); }

  .callout-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    letter-spacing: 0.12em;
    color: var(--teal);
    text-transform: uppercase;
    margin-bottom: 0.4rem;
    display: block;
  }
  .callout.amber .callout-label { color: var(--amber); }
  .callout.coral .callout-label { color: var(--coral); }
  .callout.violet .callout-label { color: var(--violet); }
  .callout.green .callout-label { color: var(--green); }
  .callout p { margin: 0; color: var(--text); }

  /* â”€â”€ CODE BLOCKS â”€â”€ */
  .code-block {
    background: var(--code-bg);
    border: 1px solid var(--border);
    border-radius: 0.75rem;
    overflow: hidden;
    margin: 1.5rem 0;
  }

  .code-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.25rem;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
  }

  .code-dot { width: 12px; height: 12px; border-radius: 50%; }
  .code-dot.red { background: #ff5f56; }
  .code-dot.yellow { background: #ffbd2e; }
  .code-dot.green { background: #27c93f; }

  .code-lang {
    margin-left: auto;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    color: var(--muted);
    letter-spacing: 0.1em;
  }

  pre {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    line-height: 1.7;
    padding: 1.5rem;
    overflow-x: auto;
    color: #e6edf3;
    tab-size: 2;
  }

  .kw { color: #ff7b72; }    /* keywords */
  .ty { color: #79c0ff; }    /* types */
  .fn { color: #d2a8ff; }    /* function names */
  .cm { color: #6a737d; font-style: italic; }  /* comments */
  .st { color: #a5d6ff; }    /* strings */
  .nm { color: #f0a830; }    /* numbers/literals */
  .op { color: #ff7b72; }    /* operators */

  /* â”€â”€ VISUAL DIAGRAM CARDS â”€â”€ */
  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
  }

  .card {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 1rem;
    padding: 1.5rem;
    transition: border-color 0.2s, transform 0.2s;
  }
  .card:hover { border-color: var(--teal-dim); transform: translateY(-2px); }

  .card-icon {
    font-size: 1.8rem;
    margin-bottom: 0.75rem;
    display: block;
  }

  .card h4 { margin: 0 0 0.5rem; font-size: 1rem; }
  .card p { margin: 0; font-size: 0.9rem; color: var(--muted); }

  /* â”€â”€ SVG GRAPH DIAGRAMS â”€â”€ */
  .graph-display {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 1rem;
    padding: 1.5rem;
    margin: 2rem 0;
    text-align: center;
  }

  .graph-display svg { max-width: 100%; }

  /* â”€â”€ TABLE â”€â”€ */
  .fancy-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 0.75rem;
    overflow: hidden;
    border: 1px solid var(--border);
    margin: 1.5rem 0;
  }
  .fancy-table th {
    background: var(--surface);
    color: var(--teal);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 0.85rem 1.25rem;
    text-align: left;
    border-bottom: 1px solid var(--border);
  }
  .fancy-table td {
    padding: 0.75rem 1.25rem;
    border-bottom: 1px solid var(--border);
    font-size: 0.9rem;
    color: #c9d1d9;
  }
  .fancy-table tr:last-child td { border-bottom: none; }
  .fancy-table tr:hover td { background: rgba(255,255,255,0.03); }
  .fancy-table td.good { color: var(--green); }
  .fancy-table td.warn { color: var(--amber); }
  .fancy-table td.bad { color: var(--coral); }

  /* â”€â”€ DFS TRACE ANIMATOR â”€â”€ */
  .trace-box {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 1rem;
    overflow: hidden;
    margin: 2rem 0;
  }

  .trace-header {
    background: var(--surface);
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .trace-title { font-family: 'DM Serif Display', serif; font-size: 1.1rem; }

  .trace-controls { display: flex; gap: 0.5rem; }

  .btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    padding: 0.45rem 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn:hover { border-color: var(--teal); color: var(--teal); }
  .btn.primary { background: var(--teal); border-color: var(--teal); color: #000; font-weight: 700; }
  .btn.primary:hover { background: #5ee7ee; }

  .trace-body {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0;
  }
  @media (max-width: 700px) { .trace-body { grid-template-columns: 1fr; } }

  .trace-graph { padding: 1.5rem; border-right: 1px solid var(--border); }
  .trace-log {
    padding: 1.5rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    max-height: 380px;
    overflow-y: auto;
  }
  .trace-log::-webkit-scrollbar { width: 4px; }
  .trace-log::-webkit-scrollbar-track { background: transparent; }
  .trace-log::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .trace-step {
    padding: 0.5rem 0.75rem;
    border-radius: 0.4rem;
    margin-bottom: 0.4rem;
    line-height: 1.5;
    color: var(--muted);
    font-size: 0.76rem;
  }
  .trace-step.active { background: rgba(57,208,216,0.1); color: var(--teal); border-left: 2px solid var(--teal); }
  .trace-step.done { color: #4a5568; }
  .trace-step.recurse { color: var(--violet); }
  .trace-step.back { color: var(--coral); }
  .trace-step.mark { color: var(--green); }
  .trace-step.tree { color: var(--amber); }

  .state-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.4rem 1rem;
    align-items: center;
    padding: 1rem 1.5rem;
    background: var(--bg);
    border-top: 1px solid var(--border);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
  }
  .state-label { color: var(--muted); }
  .state-val { display: flex; gap: 0.35rem; flex-wrap: wrap; }
  .state-cell {
    width: 28px; height: 28px;
    border-radius: 0.3rem;
    border: 1px solid var(--border);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.72rem;
    transition: all 0.3s;
    color: var(--muted);
  }
  .state-cell.marked { background: rgba(63,185,80,0.2); border-color: var(--green); color: var(--green); }
  .state-cell.current { background: rgba(57,208,216,0.2); border-color: var(--teal); color: var(--teal); box-shadow: 0 0 8px rgba(57,208,216,0.4); }

  /* â”€â”€ VERTEX NODES IN SVG â”€â”€ */
  .v-node { transition: all 0.3s; }

  /* â”€â”€ COMPARISON STRIP â”€â”€ */
  .compare-strip {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0;
    border: 1px solid var(--border);
    border-radius: 1rem;
    overflow: hidden;
    margin: 2rem 0;
  }
  .compare-side { padding: 2rem; }
  .compare-side:first-child { border-right: 1px solid var(--border); }
  .compare-side h4 { margin: 0 0 1rem; font-size: 1rem; }
  .compare-side ul { list-style: none; }
  .compare-side ul li { padding: 0.3rem 0; color: var(--muted); font-size: 0.9rem; }
  .compare-side ul li::before { content: 'â†’ '; color: var(--teal); font-family: 'JetBrains Mono', monospace; }

  /* â”€â”€ STEP LIST â”€â”€ */
  .steps { margin: 1.5rem 0; }
  .step-item {
    display: flex;
    gap: 1.25rem;
    margin-bottom: 1.5rem;
    align-items: flex-start;
  }
  .step-num {
    flex-shrink: 0;
    width: 36px; height: 36px;
    border-radius: 50%;
    background: var(--teal);
    color: #000;
    font-weight: 800;
    font-size: 0.85rem;
    display: flex; align-items: center; justify-content: center;
    font-family: 'JetBrains Mono', monospace;
    margin-top: 0.15rem;
  }
  .step-body h4 { margin: 0 0 0.35rem; color: var(--text); font-size: 1rem; text-transform: none; letter-spacing: 0; }
  .step-body p { margin: 0; font-size: 0.9rem; }

  /* â”€â”€ MATRIX VISUAL â”€â”€ */
  .matrix-vis {
    display: inline-grid;
    gap: 3px;
    background: var(--bg2);
    padding: 1rem;
    border-radius: 0.75rem;
    border: 1px solid var(--border);
  }
  .mat-cell {
    width: 36px; height: 36px;
    display: flex; align-items: center; justify-content: center;
    border-radius: 0.3rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    font-weight: 600;
  }
  .mat-cell.header { color: var(--muted); background: transparent; }
  .mat-cell.one { background: rgba(57,208,216,0.25); color: var(--teal); border: 1px solid var(--teal-dim); }
  .mat-cell.zero { background: var(--surface); color: #444; border: 1px solid transparent; }
  .mat-cell.diag { background: var(--surface); color: #555; }

  /* â”€â”€ EDGE TYPE BADGE â”€â”€ */
  .edge-badge {
    display: inline-block;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    padding: 0.2rem 0.6rem;
    border-radius: 0.3rem;
    margin: 0.15rem;
    font-weight: 700;
  }
  .edge-badge.tree { background: rgba(240,168,48,0.15); color: var(--amber); border: 1px solid rgba(240,168,48,0.3); }
  .edge-badge.back { background: rgba(255,107,107,0.15); color: var(--coral); border: 1px solid rgba(255,107,107,0.3); }
  .edge-badge.forward { background: rgba(167,139,250,0.15); color: var(--violet); border: 1px solid rgba(167,139,250,0.3); }
  .edge-badge.cross { background: rgba(88,166,255,0.15); color: var(--blue); border: 1px solid rgba(88,166,255,0.3); }

  /* â”€â”€ FOOTER â”€â”€ */
  footer {
    padding: 3rem 2rem;
    text-align: center;
    color: var(--muted);
    font-size: 0.85rem;
    border-top: 1px solid var(--border);
  }

  /* â”€â”€ ANIMATIONS â”€â”€ */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  @keyframes dash {
    to { stroke-dashoffset: 0; }
  }

  .scroll-reveal {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.5s ease, transform 0.5s ease;
  }
  .scroll-reveal.visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* adjacency list vis */
  .adj-list-vis { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; }
  .adj-row { display: flex; align-items: center; gap: 0; margin: 4px 0; }
  .adj-head {
    width: 40px; height: 32px;
    background: rgba(57,208,216,0.15);
    border: 1px solid var(--teal-dim);
    border-radius: 0.3rem 0 0 0.3rem;
    display: flex; align-items: center; justify-content: center;
    color: var(--teal); font-weight: 700; flex-shrink: 0;
  }
  .adj-node {
    height: 32px; min-width: 36px;
    padding: 0 10px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: none;
    display: flex; align-items: center; justify-content: center;
    color: var(--text);
  }
  .adj-arrow {
    height: 32px; width: 20px;
    background: var(--surface);
    border-top: 1px solid var(--border);
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: center;
    color: var(--muted); font-size: 0.7rem;
  }
  .adj-null {
    height: 32px; min-width: 40px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-left: none;
    border-radius: 0 0.3rem 0.3rem 0;
    display: flex; align-items: center; justify-content: center;
    color: #444; font-size: 0.7rem;
  }

  .inline-mono {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85em;
    background: rgba(255,255,255,0.06);
    padding: 0.1em 0.4em;
    border-radius: 0.25rem;
    color: var(--amber);
  }

  .highlight { color: var(--teal); font-weight: 700; }
  .highlight2 { color: var(--amber); font-weight: 700; }
  .highlight3 { color: var(--coral); font-weight: 700; }

  .complexity {
    display: inline-block;
    font-family: 'JetBrains Mono', monospace;
    background: rgba(167,139,250,0.12);
    color: var(--violet);
    border: 1px solid rgba(167,139,250,0.25);
    padding: 0.15rem 0.6rem;
    border-radius: 0.3rem;
    font-size: 0.85rem;
  }

  @media (max-width: 600px) {
    .compare-strip { grid-template-columns: 1fr; }
    .compare-side:first-child { border-right: none; border-bottom: 1px solid var(--border); }
  }
</style>
</head>
<body>

<!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HERO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div class="hero">
  <div class="hero-bg"></div>

  <!-- Animated background graph SVG -->
  <svg class="hero-graph" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid slice">
    <defs>
      <marker id="ah" markerWidth="8" markerHeight="8" refX="4" refY="4" orient="auto">
        <circle cx="4" cy="4" r="2" fill="#39d0d8"/>
      </marker>
    </defs>
    <!-- bg edges -->
    <line x1="200" y1="150" x2="450" y2="300" stroke="#39d0d8" stroke-width="1"/>
    <line x1="450" y1="300" x2="700" y2="180" stroke="#39d0d8" stroke-width="1"/>
    <line x1="700" y1="180" x2="950" y2="350" stroke="#39d0d8" stroke-width="1"/>
    <line x1="950" y1="350" x2="1050" y2="550" stroke="#39d0d8" stroke-width="1"/>
    <line x1="200" y1="150" x2="150" y2="400" stroke="#39d0d8" stroke-width="1"/>
    <line x1="150" y1="400" x2="450" y2="300" stroke="#39d0d8" stroke-width="1"/>
    <line x1="450" y1="300" x2="600" y2="500" stroke="#39d0d8" stroke-width="1"/>
    <line x1="700" y1="180" x2="850" y2="80" stroke="#39d0d8" stroke-width="1"/>
    <line x1="600" y1="500" x2="950" y2="350" stroke="#39d0d8" stroke-width="1"/>
    <!-- nodes -->
    <circle cx="200" cy="150" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="450" cy="300" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="700" cy="180" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="950" cy="350" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="1050" cy="550" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="150" cy="400" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="600" cy="500" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
    <circle cx="850" cy="80" r="18" fill="#0e3a4a" stroke="#39d0d8" stroke-width="1.5"/>
  </svg>

  <div class="hero-content">
    <span class="lecture-tag">LECTURE 09 OF 12 Â· DATA STRUCTURES &amp; ALGORITHMS</span>
    <h1 class="hero-title">
      <span class="accent">Graph</span> Fundamentals<br>
      &amp; <span class="accent2">Depth-First</span> Search
    </h1>
    <p class="hero-sub">A complete beginner-friendly guide to graph theory, representations, traversal, and classic applications â€” with C++ code throughout.</p>
    <div class="hero-pills">
      <span class="pill">Vertices &amp; Edges</span>
      <span class="pill">Adjacency Matrix</span>
      <span class="pill">Adjacency List</span>
      <span class="pill">DFS Recursive</span>
      <span class="pill">DFS Iterative</span>
      <span class="pill">Cycle Detection</span>
      <span class="pill">Connected Components</span>
      <span class="pill">Edge Classification</span>
    </div>
  </div>
</div>

<!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NAV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<nav class="toc">
  <a href="#sec-what">Â§1 What is a Graph?</a>
  <a href="#sec-terms">Â§2 Terminology</a>
  <a href="#sec-types">Â§3 Graph Types</a>
  <a href="#sec-repr">Â§4 Representations</a>
  <a href="#sec-dfs">Â§5 Depth-First Search</a>
  <a href="#sec-apps">Â§6 DFS Applications</a>
  <a href="#sec-edges">Â§7 Edge Classification</a>
  <a href="#sec-design">Â§8 Design Pattern</a>
  <a href="#sec-complexity">Â§9 Complexity</a>
</nav>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§1  WHAT IS A GRAPH -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-what">
<div class="container">
  <span class="section-num">SECTION 01</span>
  <h2 class="section-title">What <em>is</em> a Graph?</h2>

  <p>A <span class="highlight">graph</span> is the most general data structure in all of computer science. Every other structure you've learned â€” arrays, linked lists, stacks, trees â€” models a very specific kind of relationship. A graph makes only one claim: <em>"here are some things, and here are pairwise connections between them."</em></p>

  <div class="callout">
    <span class="callout-label">Core Idea</span>
    <p>A graph <strong>G = (V, E)</strong> consists of a set <strong>V</strong> of <em>vertices</em> (the "things") and a set <strong>E</strong> of <em>edges</em> (the "connections"). That's it.</p>
  </div>

  <p>Because graphs are so general, they appear everywhere. Think of any situation where you have objects and relationships between them â€” you have a graph.</p>

  <div class="card-grid scroll-reveal">
    <div class="card">
      <span class="card-icon">ğŸŒ</span>
      <h4>The World Wide Web</h4>
      <p>Web pages are vertices. Hyperlinks are directed edges. PageRank is a graph algorithm.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ—ºï¸</span>
      <h4>Road Networks</h4>
      <p>Intersections are vertices. Road segments are weighted edges. GPS navigation solves shortest-path on this graph.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ‘¥</span>
      <h4>Social Networks</h4>
      <p>People are vertices. Friendships are edges. Finding communities means finding connected components.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ“¦</span>
      <h4>Task Scheduling</h4>
      <p>Tasks are vertices. "Must come before" constraints are directed edges. Valid orderings come from topological sort.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ§¬</span>
      <h4>Biology</h4>
      <p>Proteins are vertices. Interactions are edges. Graph algorithms find functional clusters.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ–¥ï¸</span>
      <h4>Compilers</h4>
      <p>Modules are vertices. Import dependencies are edges. Cycle detection finds circular dependencies.</p>
    </div>
  </div>

  <h3>A Visual Intuition</h3>
  <p>Let's start with a tiny concrete graph. Imagine 5 cities connected by flights:</p>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 320" width="700" height="320">
      <defs>
        <marker id="arr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#39d0d8"/>
        </marker>
      </defs>

      <!-- edges -->
      <line x1="180" y1="160" x2="340" y2="100" stroke="#30363d" stroke-width="2"/>
      <line x1="340" y1="100" x2="500" y2="160" stroke="#30363d" stroke-width="2"/>
      <line x1="180" y1="160" x2="340" y2="240" stroke="#30363d" stroke-width="2"/>
      <line x1="340" y1="240" x2="500" y2="160" stroke="#30363d" stroke-width="2"/>
      <line x1="340" y1="100" x2="340" y2="240" stroke="#30363d" stroke-width="2"/>
      <line x1="500" y1="160" x2="600" y2="100" stroke="#30363d" stroke-width="2"/>

      <!-- edge weight labels -->
      <text x="248" y="110" fill="#6a737d" font-family="JetBrains Mono" font-size="12">420mi</text>
      <text x="410" y="110" fill="#6a737d" font-family="JetBrains Mono" font-size="12">385mi</text>
      <text x="225" y="220" fill="#6a737d" font-family="JetBrains Mono" font-size="12">210mi</text>
      <text x="410" y="225" fill="#6a737d" font-family="JetBrains Mono" font-size="12">310mi</text>
      <text x="350" y="178" fill="#6a737d" font-family="JetBrains Mono" font-size="12">500mi</text>
      <text x="535" y="115" fill="#6a737d" font-family="JetBrains Mono" font-size="12">95mi</text>

      <!-- vertex: A (NYC) -->
      <circle cx="180" cy="160" r="36" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="180" y="155" text-anchor="middle" fill="#39d0d8" font-family="DM Serif Display" font-size="16" font-weight="bold">A</text>
      <text x="180" y="172" text-anchor="middle" fill="#6a737d" font-family="Nunito" font-size="10">NYC</text>

      <!-- vertex: B (Chicago) -->
      <circle cx="340" cy="100" r="36" fill="#0d1117" stroke="#f0a830" stroke-width="2"/>
      <text x="340" y="95" text-anchor="middle" fill="#f0a830" font-family="DM Serif Display" font-size="16" font-weight="bold">B</text>
      <text x="340" y="112" text-anchor="middle" fill="#6a737d" font-family="Nunito" font-size="10">Chicago</text>

      <!-- vertex: C (Miami) -->
      <circle cx="340" cy="240" r="36" fill="#0d1117" stroke="#a78bfa" stroke-width="2"/>
      <text x="340" y="235" text-anchor="middle" fill="#a78bfa" font-family="DM Serif Display" font-size="16" font-weight="bold">C</text>
      <text x="340" y="252" text-anchor="middle" fill="#6a737d" font-family="Nunito" font-size="10">Miami</text>

      <!-- vertex: D (Dallas) -->
      <circle cx="500" cy="160" r="36" fill="#0d1117" stroke="#3fb950" stroke-width="2"/>
      <text x="500" y="155" text-anchor="middle" fill="#3fb950" font-family="DM Serif Display" font-size="16" font-weight="bold">D</text>
      <text x="500" y="172" text-anchor="middle" fill="#6a737d" font-family="Nunito" font-size="10">Dallas</text>

      <!-- vertex: E (Austin) -->
      <circle cx="600" cy="100" r="36" fill="#0d1117" stroke="#ff6b6b" stroke-width="2"/>
      <text x="600" y="95" text-anchor="middle" fill="#ff6b6b" font-family="DM Serif Display" font-size="16" font-weight="bold">E</text>
      <text x="600" y="112" text-anchor="middle" fill="#6a737d" font-family="Nunito" font-size="10">Austin</text>

      <!-- labels -->
      <text x="60" y="30" fill="#8b949e" font-family="Nunito" font-size="13">5 vertices (cities) Â· 6 edges (flight routes) Â· weighted (distance)</text>
    </svg>
  </div>

  <p>This is an <strong>undirected weighted graph</strong>. Undirected because flights go both ways; weighted because edges carry distances. Each circle is a <em>vertex</em>; each line is an <em>edge</em>.</p>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§2  TERMINOLOGY -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-terms">
<div class="container">
  <span class="section-num">SECTION 02</span>
  <h2 class="section-title">The Language of Graphs</h2>
  <p>Before we can talk about algorithms, we need precise vocabulary. Don't be intimidated â€” these are simply names for things you already understand intuitively.</p>

  <h3>Degree</h3>
  <p>The <span class="highlight">degree</span> of a vertex is the number of edges connected to it. Think of it as "how many neighbors does this vertex have?"</p>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 600 260" width="600" height="260">
      <!-- edges -->
      <line x1="300" y1="130" x2="160" y2="60" stroke="#30363d" stroke-width="2"/>
      <line x1="300" y1="130" x2="430" y2="60" stroke="#30363d" stroke-width="2"/>
      <line x1="300" y1="130" x2="160" y2="200" stroke="#30363d" stroke-width="2"/>
      <line x1="300" y1="130" x2="430" y2="200" stroke="#30363d" stroke-width="2"/>
      <line x1="160" y1="60" x2="430" y2="60" stroke="#30363d" stroke-width="2" stroke-dasharray="4"/>
      <!-- center node -->
      <circle cx="300" cy="130" r="34" fill="rgba(57,208,216,0.15)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="300" y="126" text-anchor="middle" fill="#39d0d8" font-family="DM Serif Display" font-size="18">V</text>
      <text x="300" y="145" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="10">deg = 4</text>
      <!-- outer nodes -->
      <circle cx="160" cy="60" r="26" fill="#161b22" stroke="#30363d" stroke-width="1.5"/>
      <text x="160" y="65" text-anchor="middle" fill="#8b949e" font-family="DM Serif Display" font-size="14">A</text>
      <circle cx="430" cy="60" r="26" fill="#161b22" stroke="#30363d" stroke-width="1.5"/>
      <text x="430" y="65" text-anchor="middle" fill="#8b949e" font-family="DM Serif Display" font-size="14">B</text>
      <circle cx="160" cy="200" r="26" fill="#161b22" stroke="#30363d" stroke-width="1.5"/>
      <text x="160" y="205" text-anchor="middle" fill="#8b949e" font-family="DM Serif Display" font-size="14">C</text>
      <circle cx="430" cy="200" r="26" fill="#161b22" stroke="#30363d" stroke-width="1.5"/>
      <text x="430" y="205" text-anchor="middle" fill="#8b949e" font-family="DM Serif Display" font-size="14">D</text>
      <!-- annotation -->
      <text x="295" y="30" text-anchor="middle" fill="#8b949e" font-family="Nunito" font-size="12">Vertex V has 4 edges â†’ degree(V) = 4</text>
      <text x="295" y="250" text-anchor="middle" fill="#444" font-family="Nunito" font-size="11">The dashed edge (Aâ€“B) doesn't connect to V, so it doesn't count</text>
    </svg>
  </div>

  <div class="callout amber scroll-reveal">
    <span class="callout-label">Handshaking Lemma</span>
    <p>The sum of all vertex degrees = <strong>2 Ã— (number of edges)</strong>. Every edge contributes exactly 1 to two vertices' degrees. This is one of graph theory's most elegant facts.</p>
  </div>

  <h3>Paths and Cycles</h3>

  <div class="card-grid scroll-reveal">
    <div class="card">
      <h4>ğŸ›¤ï¸ Path</h4>
      <p>A sequence of vertices where each consecutive pair is connected by an edge. Example: Aâ†’Bâ†’Câ†’D is a path of <em>length 3</em> (3 edges). A <strong>simple path</strong> never repeats a vertex.</p>
    </div>
    <div class="card">
      <h4>ğŸ”„ Cycle</h4>
      <p>A path that starts and ends at the same vertex. Example: Aâ†’Bâ†’Câ†’A is a cycle of length 3. A <strong>simple cycle</strong> repeats only the start/end vertex.</p>
    </div>
    <div class="card">
      <h4>ğŸ§© Connectivity</h4>
      <p>A graph is <strong>connected</strong> if you can reach every vertex from every other vertex. A <strong>connected component</strong> is a maximal connected chunk of the graph.</p>
    </div>
  </div>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 280" width="700" height="280">
      <!-- Component 1 (connected) -->
      <text x="180" y="25" text-anchor="middle" fill="#3fb950" font-family="Nunito" font-size="13" font-weight="700">Connected Component 1</text>
      <line x1="80" y1="140" x2="180" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <line x1="180" y1="80" x2="280" y2="140" stroke="#f0a830" stroke-width="2.5"/><!-- path highlight -->
      <line x1="280" y1="140" x2="180" y2="200" stroke="#39d0d8" stroke-width="2"/>
      <line x1="180" y1="200" x2="80" y2="140" stroke="#39d0d8" stroke-width="2"/>
      <line x1="180" y1="80" x2="180" y2="200" stroke="#39d0d8" stroke-width="2" stroke-dasharray="5,3"/>
      <circle cx="80" cy="140" r="26" fill="rgba(57,208,216,0.12)" stroke="#39d0d8" stroke-width="2"/>
      <text x="80" y="145" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">0</text>
      <circle cx="180" cy="80" r="26" fill="rgba(240,168,48,0.2)" stroke="#f0a830" stroke-width="2.5"/>
      <text x="180" y="85" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="13">1</text>
      <circle cx="280" cy="140" r="26" fill="rgba(240,168,48,0.2)" stroke="#f0a830" stroke-width="2.5"/>
      <text x="280" y="145" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="13">2</text>
      <circle cx="180" cy="200" r="26" fill="rgba(57,208,216,0.12)" stroke="#39d0d8" stroke-width="2"/>
      <text x="180" y="205" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">3</text>
      <text x="170" y="260" text-anchor="middle" fill="#f0a830" font-family="Nunito" font-size="11">path: 0â†’1â†’2 (highlighted)</text>

      <!-- divider -->
      <line x1="370" y1="40" x2="370" y2="250" stroke="#30363d" stroke-width="1" stroke-dasharray="6,4"/>
      <text x="370" y="260" text-anchor="middle" fill="#444" font-family="Nunito" font-size="11">disconnected</text>

      <!-- Component 2 -->
      <text x="530" y="25" text-anchor="middle" fill="#3fb950" font-family="Nunito" font-size="13" font-weight="700">Connected Component 2</text>
      <line x1="430" y1="130" x2="530" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <line x1="430" y1="130" x2="530" y2="180" stroke="#39d0d8" stroke-width="2"/>
      <line x1="530" y1="80" x2="630" y2="130" stroke="#ff6b6b" stroke-width="2.5"/><!-- cycle highlight -->
      <line x1="630" y1="130" x2="530" y2="180" stroke="#ff6b6b" stroke-width="2.5"/>
      <line x1="530" y1="80" x2="530" y2="180" stroke="#ff6b6b" stroke-width="2.5"/>
      <circle cx="430" cy="130" r="26" fill="rgba(57,208,216,0.12)" stroke="#39d0d8" stroke-width="2"/>
      <text x="430" y="135" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">4</text>
      <circle cx="530" cy="80" r="26" fill="rgba(255,107,107,0.15)" stroke="#ff6b6b" stroke-width="2.5"/>
      <text x="530" y="85" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="13">5</text>
      <circle cx="630" cy="130" r="26" fill="rgba(255,107,107,0.15)" stroke="#ff6b6b" stroke-width="2.5"/>
      <text x="630" y="135" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="13">6</text>
      <circle cx="530" cy="180" r="26" fill="rgba(255,107,107,0.15)" stroke="#ff6b6b" stroke-width="2.5"/>
      <text x="530" y="185" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="13">7</text>
      <text x="530" y="260" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="11">cycle: 5â†’6â†’7â†’5 (highlighted)</text>
    </svg>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§3  GRAPH TYPES -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-types">
<div class="container">
  <span class="section-num">SECTION 03</span>
  <h2 class="section-title">Types of Graphs</h2>
  <p>Not all graphs are the same. Here are the key varieties you'll encounter:</p>

  <div class="card-grid scroll-reveal">
    <div class="card">
      <h4>â†”ï¸ Undirected</h4>
      <p>Edges have no direction. If A connects to B, then B connects to A. Friendship on Facebook. Most of what we study today.</p>
    </div>
    <div class="card">
      <h4>â†’ Directed (Digraph)</h4>
      <p>Edges have direction. Aâ†’B does NOT mean Bâ†’A. Twitter follows, hyperlinks, one-way streets.</p>
    </div>
    <div class="card">
      <h4>âš–ï¸ Weighted</h4>
      <p>Each edge carries a number (distance, cost, capacity). Used for shortest paths and minimum spanning trees.</p>
    </div>
    <div class="card">
      <h4>ğŸ¨ Bipartite</h4>
      <p>Vertices split into two groups; every edge connects one group to the other. Movieâ€“actor relationships. Equivalent: no odd-length cycles.</p>
    </div>
    <div class="card">
      <h4>ğŸŒ² Tree</h4>
      <p>A connected graph with no cycles. Has exactly Vâ€“1 edges. The backbone of DFS traversal is a tree.</p>
    </div>
    <div class="card">
      <h4>ğŸŒ³ Forest</h4>
      <p>Multiple disconnected trees. A graph with no cycles (possibly disconnected). DFS on a disconnected graph produces a forest.</p>
    </div>
  </div>

  <div class="callout violet scroll-reveal">
    <span class="callout-label">Key Theorem</span>
    <p>A tree on V vertices has <strong>exactly V âˆ’ 1 edges</strong>. A connected graph must have <strong>at least V âˆ’ 1 edges</strong>. If a connected graph has exactly V âˆ’ 1 edges, it is a tree (acyclic).</p>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§4  REPRESENTATIONS -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-repr">
<div class="container">
  <span class="section-num">SECTION 04</span>
  <h2 class="section-title">Storing a Graph in Memory</h2>
  <p>We have two standard ways to represent a graph in a computer. The choice matters enormously for performance.</p>

  <p>We'll use this simple 5-vertex graph as our running example:</p>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 500 230" width="500" height="230">
      <line x1="250" y1="50" x2="130" y2="150" stroke="#30363d" stroke-width="2"/>
      <line x1="250" y1="50" x2="370" y2="150" stroke="#30363d" stroke-width="2"/>
      <line x1="130" y1="150" x2="250" y2="190" stroke="#30363d" stroke-width="2"/>
      <line x1="370" y1="150" x2="250" y2="190" stroke="#30363d" stroke-width="2"/>
      <line x1="130" y1="150" x2="370" y2="150" stroke="#30363d" stroke-width="2"/>
      <circle cx="250" cy="50" r="26" fill="rgba(57,208,216,0.15)" stroke="#39d0d8" stroke-width="2"/>
      <text x="250" y="56" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="14">0</text>
      <circle cx="130" cy="150" r="26" fill="rgba(240,168,48,0.15)" stroke="#f0a830" stroke-width="2"/>
      <text x="130" y="156" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="14">1</text>
      <circle cx="370" cy="150" r="26" fill="rgba(167,139,250,0.15)" stroke="#a78bfa" stroke-width="2"/>
      <text x="370" y="156" text-anchor="middle" fill="#a78bfa" font-family="JetBrains Mono" font-size="14">2</text>
      <circle cx="250" cy="190" r="26" fill="rgba(255,107,107,0.15)" stroke="#ff6b6b" stroke-width="2"/>
      <text x="250" y="196" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="14">3</text>
      <text x="250" y="220" text-anchor="middle" fill="#6a737d" font-family="Nunito" font-size="11">4 vertices: 0,1,2,3 Â· 5 edges: {0,1}{0,2}{1,2}{1,3}{2,3}</text>
    </svg>
  </div>

  <!-- â”€â”€ ADJACENCY MATRIX â”€â”€ -->
  <h3>Option 1: Adjacency Matrix</h3>
  <p>Create a <span class="highlight">V Ã— V grid of true/false values</span>. Put <span class="inline-mono">true</span> at position [u][v] if there's an edge between vertex u and vertex v.</p>

  <div class="graph-display scroll-reveal">
    <p style="color:var(--muted);font-size:0.85rem;margin-bottom:1rem;">4Ã—4 adjacency matrix for our graph above</p>
    <div style="display:flex;gap:2rem;justify-content:center;flex-wrap:wrap;align-items:flex-start">
      <!-- matrix -->
      <div>
        <div class="matrix-vis" style="grid-template-columns: repeat(5, 36px)">
          <!-- header row -->
          <div class="mat-cell header"></div>
          <div class="mat-cell header" style="color:#39d0d8">0</div>
          <div class="mat-cell header" style="color:#f0a830">1</div>
          <div class="mat-cell header" style="color:#a78bfa">2</div>
          <div class="mat-cell header" style="color:#ff6b6b">3</div>
          <!-- row 0 -->
          <div class="mat-cell header" style="color:#39d0d8">0</div>
          <div class="mat-cell diag">â€”</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell zero">0</div>
          <!-- row 1 -->
          <div class="mat-cell header" style="color:#f0a830">1</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell diag">â€”</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell one">1</div>
          <!-- row 2 -->
          <div class="mat-cell header" style="color:#a78bfa">2</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell diag">â€”</div>
          <div class="mat-cell one">1</div>
          <!-- row 3 -->
          <div class="mat-cell header" style="color:#ff6b6b">3</div>
          <div class="mat-cell zero">0</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell one">1</div>
          <div class="mat-cell diag">â€”</div>
        </div>
        <p style="font-size:0.78rem;color:var(--muted);margin-top:0.5rem;font-family:'JetBrains Mono',monospace">
          <span style="color:var(--teal)">â– </span> 1 = edge exists &nbsp; <span style="color:#444">â– </span> 0 = no edge
        </p>
      </div>

      <!-- explanation -->
      <div style="text-align:left;max-width:300px">
        <p style="font-size:0.9rem">Reading the matrix: row = "from", column = "to". Since undirected, the matrix is <em>symmetric</em> â€” [u][v] always equals [v][u].</p>
        <p style="font-size:0.9rem">To check if edge {1,2} exists: just look at <span class="inline-mono">adj[1][2]</span> â†’ <span style="color:var(--teal)">1</span> (true). Instant!</p>
        <p style="font-size:0.9rem;color:var(--coral)">âš ï¸ But to find all neighbors of vertex 1, you must scan the entire row 1 â€” even the zeros.</p>
      </div>
    </div>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· Adjacency Matrix</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Adjacency Matrix: a VÃ—V boolean grid.
   adj[u][v] = true   â†’ edge {u,v} exists
   adj[u][v] = false  â†’ no edge
 Memory: Î˜(VÂ²) regardless of how many edges exist.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

V: integer                           <span class="cm">// number of vertices</span>
adj[0..V-1][0..V-1]: boolean matrix  <span class="cm">// all false initially</span>

<span class="fn">addEdge</span>(u, v):                       <span class="cm">// add undirected edge {u, v}</span>
    adj[u][v] â† true                 <span class="cm">// u â†’ v direction</span>
    adj[v][u] â† true                 <span class="cm">// v â†’ u direction (undirected = symmetric)</span>

<span class="fn">hasEdge</span>(u, v) â†’ boolean:             <span class="cm">// O(1) âš¡ â€” the matrix's advantage</span>
    return adj[u][v]

<span class="fn">neighbors</span>(u):                        <span class="cm">// O(V) ğŸ¢ â€” must scan entire row</span>
    <span class="kw">for</span> v <span class="kw">in</span> 0..V-1:
        <span class="kw">if</span> adj[u][v] = true: yield v   <span class="cm">// even if u has just 1 neighbor, we check all V</span>

<span class="cm">â”€â”€ Example â”€â”€</span>
G â† matrix with V=4
<span class="fn">addEdge</span>(0,1)  <span class="fn">addEdge</span>(0,2)  <span class="fn">addEdge</span>(1,2)  <span class="fn">addEdge</span>(1,3)  <span class="fn">addEdge</span>(2,3)
<span class="fn">hasEdge</span>(1,2)  â†’ true    <span class="cm">// edge {1,2} exists</span>
<span class="fn">hasEdge</span>(0,3)  â†’ false   <span class="cm">// no direct edge {0,3}</span>
<span class="fn">neighbors</span>(1)  â†’ 0,2,3   <span class="cm">// scans all 4 slots to find 3 neighbors</span></pre>
  </div>

  <!-- â”€â”€ ADJACENCY LIST â”€â”€ -->
  <h3>Option 2: Adjacency List</h3>
  <p>For each vertex, store only the vertices it's <em>actually connected to</em>. No wasted space for non-edges.</p>

  <div class="graph-display scroll-reveal">
    <p style="color:var(--muted);font-size:0.85rem;margin-bottom:1.25rem;">Adjacency list for the same graph</p>
    <div class="adj-list-vis" style="display:inline-block;text-align:left">
      <div class="adj-row">
        <div class="adj-head">0</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#f0a830">1</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#a78bfa">2</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-null">null</div>
      </div>
      <div class="adj-row">
        <div class="adj-head" style="color:#f0a830">1</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node">0</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#a78bfa">2</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#ff6b6b">3</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-null">null</div>
      </div>
      <div class="adj-row">
        <div class="adj-head" style="color:#a78bfa">2</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node">0</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#f0a830">1</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#ff6b6b">3</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-null">null</div>
      </div>
      <div class="adj-row">
        <div class="adj-head" style="color:#ff6b6b">3</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#f0a830">1</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-node" style="color:#a78bfa">2</div>
        <div class="adj-arrow">â†’</div>
        <div class="adj-null">null</div>
      </div>
    </div>
    <p style="font-size:0.8rem;color:var(--muted);margin-top:1rem">Each row stores only the actual neighbors. No zeros. No wasted space.</p>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· Graph â€” Adjacency List</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Adjacency List: for each vertex, store a list of its neighbors.
   adj[0] = {1, 2}      â† vertex 0 connects to 1 and 2
   adj[1] = {0, 2, 3}   â† vertex 1 connects to 0, 2, 3
   adj[2] = {0, 1, 3}   â† vertex 2 connects to 0, 1, 3
   adj[3] = {1, 2}      â† vertex 3 connects to 1 and 2
 Only real edges consume space â€” no wasted zeros!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="kw">class</span> <span class="ty">Graph</span>:
    V: integer             <span class="cm">// total number of vertices</span>
    E: integer             <span class="cm">// total number of edges added so far</span>
    adj[0..V-1]: list      <span class="cm">// adj[v] = list of v's neighbors</span>

    <span class="fn">Graph</span>(V):              <span class="cm">// create V vertices, zero edges</span>
        V â† V, E â† 0
        adj â† V empty lists

    <span class="fn">addEdge</span>(u, v):         <span class="cm">// add undirected edge {u, v}</span>
        adj[u].append(v)   <span class="cm">// v appears in u's neighbor list</span>
        adj[v].append(u)   <span class="cm">// u appears in v's neighbor list (undirected!)</span>
        E â† E + 1

    <span class="fn">neighbors</span>(v): return adj[v]    <span class="cm">// O(degree(v)) iteration â€” no wasted work</span>
    <span class="fn">numVertices</span>(): return V
    <span class="fn">numEdges</span>():    return E

<span class="cm">â”€â”€ Example usage â”€â”€</span>
G â† <span class="kw">new</span> <span class="ty">Graph</span>(4)
G.<span class="fn">addEdge</span>(0, 1)    <span class="cm">// adj[0]={1}     adj[1]={0}</span>
G.<span class="fn">addEdge</span>(0, 2)    <span class="cm">// adj[0]={1,2}   adj[2]={0}</span>
G.<span class="fn">addEdge</span>(1, 2)    <span class="cm">// adj[1]={0,2}   adj[2]={0,1}</span>
G.<span class="fn">addEdge</span>(1, 3)    <span class="cm">// adj[1]={0,2,3} adj[3]={1}</span>
G.<span class="fn">addEdge</span>(2, 3)    <span class="cm">// adj[2]={0,1,3} adj[3]={1,2}</span>

<span class="kw">for</span> w <span class="kw">in</span> G.<span class="fn">neighbors</span>(1):   <span class="cm">// visits only 0, 2, 3 â€” no wasted work</span>
    print "Neighbor of 1:", w
<span class="cm">// Output: 0  2  3</span></pre>
  </div>

  <!-- â”€â”€ COMPARISON â”€â”€ -->
  <h3>Choosing Between Them</h3>
  <table class="fancy-table scroll-reveal">
    <thead>
      <tr>
        <th>Operation</th>
        <th>Adjacency Matrix</th>
        <th>Adjacency List</th>
        <th>Winner</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Memory space</td>
        <td class="warn">Î˜(VÂ²)</td>
        <td class="good">Î˜(V + E)</td>
        <td class="good">List ğŸ†</td>
      </tr>
      <tr>
        <td>Check if edge {u,v} exists</td>
        <td class="good">O(1) â€” instant!</td>
        <td class="warn">O(degree(u))</td>
        <td class="good">Matrix ğŸ†</td>
      </tr>
      <tr>
        <td>Iterate all neighbors of u</td>
        <td class="warn">O(V) â€” scan whole row</td>
        <td class="good">O(degree(u))</td>
        <td class="good">List ğŸ†</td>
      </tr>
      <tr>
        <td>Add an edge</td>
        <td class="good">O(1)</td>
        <td class="good">O(1)</td>
        <td>Tie</td>
      </tr>
      <tr>
        <td>Best for</td>
        <td>Dense graphs (E â‰ˆ VÂ²)</td>
        <td class="good">Sparse graphs (most real graphs)</td>
        <td class="good">List (usually)</td>
      </tr>
    </tbody>
  </table>

  <div class="callout coral scroll-reveal">
    <span class="callout-label">Real-World Scale</span>
    <p>Facebook has ~3 billion users. An adjacency matrix would need 3Ã—10â¹ Ã— 3Ã—10â¹ = <strong>9Ã—10Â¹â¸ bits</strong> â€” roughly a billion terabytes. Impossible. An adjacency list needs only space proportional to the actual number of friendships. <strong>Use adjacency lists for sparse graphs.</strong></p>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§5  DEPTH-FIRST SEARCH -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-dfs">
<div class="container">
  <span class="section-num">SECTION 05</span>
  <h2 class="section-title">Depth-First Search</h2>

  <p>Depth-First Search (DFS) is a <span class="highlight">graph traversal algorithm</span> â€” a systematic way to visit every vertex reachable from a starting point. The key insight is deceptively simple:</p>

  <div class="callout scroll-reveal">
    <span class="callout-label">The DFS Idea</span>
    <p><strong>Explore as deep as possible before backtracking.</strong> From the current vertex, pick any unvisited neighbor and go there. Keep going until you hit a dead end (no unvisited neighbors). Then backtrack and try a different path.</p>
  </div>

  <p>It's exactly how you'd explore a maze: pick a corridor and walk down it until you're stuck, then retrace your steps to try a different corridor. Tremaux described this strategy in the 1880s for maze-solving.</p>

  <h3>The marked[] Array â€” The Key Data Structure</h3>
  <p>The most important piece of DFS is the <span class="inline-mono">marked[]</span> array (sometimes called <span class="inline-mono">visited[]</span>). It's a simple boolean array, one entry per vertex:</p>

  <div class="callout amber scroll-reveal">
    <span class="callout-label">marked[] serves two critical purposes</span>
    <p><strong>1. Termination:</strong> Without it, DFS would loop forever around any cycle. We only visit a vertex if it's not yet marked.<br>
    <strong>2. Efficiency:</strong> Each vertex is processed exactly once â†’ linear time O(V + E).</p>
  </div>

  <!-- â”€â”€ RECURSIVE DFS â”€â”€ -->
  <h3>Recursive DFS â€” The Elegant Version</h3>
  <p>The recursive version is beautifully simple. The call stack handles backtracking automatically.</p>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· Recursive DFS</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Recursive DFS: go as deep as possible, backtrack automatically.
 The call stack handles backtracking â€” when dfs(w) returns,
 we're back at v continuing to its next neighbor.

 Two arrays power everything:
   marked[v] = true â†’ v has been visited (prevents loops!)
   edgeTo[v]  = u   â†’ "we first reached v by coming from u"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="cm">â”€â”€ Global state â”€â”€</span>
marked[0..V-1] â† all false    <span class="cm">// has each vertex been visited?</span>
edgeTo[0..V-1] â† all -1       <span class="cm">// parent pointer (-1 = "not reached yet")</span>

<span class="cm">â”€â”€ Core DFS function â€” called recursively â”€â”€</span>
<span class="fn">dfs</span>(Graph G, vertex v):

    marked[v] â† true              <span class="cm">// â‘  MARK: claim v (prevents revisiting)</span>

    <span class="kw">for each</span> neighbor w <span class="kw">of</span> v:    <span class="cm">// â‘¡ EXPLORE: scan v's adjacency list</span>

        <span class="kw">if</span> marked[w] = false:      <span class="cm">// â‘¢ SKIP: if already visited, do nothing</span>

            edgeTo[w] â† v         <span class="cm">// â‘£ RECORD: "we discovered w by coming from v"</span>

            <span class="fn">dfs</span>(G, w)             <span class="cm">// â‘¤ DIVE: recurse as deep as possible from w</span>
                                  <span class="cm">//    â†’ when this returns, we auto-backtrack to v</span>
                                  <span class="cm">//    â†’ continue checking v's remaining neighbors</span>

    <span class="cm">// All of v's neighbors are marked. Return â†’ backtrack one level.</span>

<span class="cm">â”€â”€ Run DFS on every vertex (handles disconnected graphs) â”€â”€</span>
<span class="fn">dfsAll</span>(Graph G):
    marked â† all false
    edgeTo â† all -1
    <span class="kw">for</span> v <span class="kw">in</span> 0..V-1:
        <span class="kw">if</span> marked[v] = false:
            <span class="fn">dfs</span>(G, v)            <span class="cm">// explore v's entire connected component</span>
        <span class="cm">// if v was already marked, its component was handled earlier</span></pre>
  </div>

  <div class="steps scroll-reveal">
    <div class="step-item">
      <div class="step-num">1</div>
      <div class="step-body">
        <h4>Mark the current vertex</h4>
        <p>Set <span class="inline-mono">marked[v] = true</span>. This prevents revisiting v and handles cycles.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">2</div>
      <div class="step-body">
        <h4>Look at each neighbor</h4>
        <p>Loop through <span class="inline-mono">G.neighbors(v)</span> â€” the adjacency list of v.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">3</div>
      <div class="step-body">
        <h4>Skip visited neighbors</h4>
        <p>If <span class="inline-mono">marked[w]</span> is already true, skip w â€” we've been there.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">4</div>
      <div class="step-body">
        <h4>Record the path</h4>
        <p>Set <span class="inline-mono">edgeTo[w] = v</span>. This means "we discovered w by coming from v." It lets us reconstruct paths later.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">5</div>
      <div class="step-body">
        <h4>Recurse (go deeper)</h4>
        <p>Call <span class="inline-mono">dfs(G, w)</span>. The function goes as deep as it can from w. When it returns, we automatically "backtrack" to continue with v's other neighbors.</p>
      </div>
    </div>
  </div>

  <!-- â”€â”€ INTERACTIVE TRACE â”€â”€ -->
  <h3>Interactive DFS Trace</h3>
  <p>Step through DFS on a 6-vertex graph. Watch the <strong style="color:var(--amber)">call stack grow and shrink</strong> as the algorithm dives and backtracks, and see the <strong style="color:var(--teal)">active pseudocode line</strong> highlighted in real time.</p>

  <style>
    /* â”€â”€ Enhanced trace layout â”€â”€ */
    .trace-box2 {
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 1rem;
      overflow: hidden;
      margin: 1.5rem 0;
    }
    .trace-header2 {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.9rem 1.4rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg3);
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .trace-title2 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.78rem;
      color: var(--teal);
      letter-spacing: 0.08em;
    }
    .trace-controls2 { display: flex; gap: 0.5rem; align-items: center; }
    .btn2 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.78rem;
      padding: 0.45rem 1rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--muted);
      cursor: pointer;
      transition: all 0.15s;
    }
    .btn2:hover { color: var(--teal); border-color: var(--teal-dim); }
    .btn2.primary2 { background: rgba(57,208,216,0.12); border-color: var(--teal-dim); color: var(--teal); }
    .btn2.primary2:hover { background: rgba(57,208,216,0.22); }
    .btn2:disabled { opacity: 0.4; cursor: default; }

    .step-counter {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
      color: var(--muted);
      padding: 0.3rem 0.7rem;
      background: var(--surface);
      border-radius: 0.3rem;
      border: 1px solid var(--border);
    }

    /* â”€â”€ Three-column trace body â”€â”€ */
    .trace-body2 {
      display: grid;
      grid-template-columns: 280px 1fr 220px;
      min-height: 380px;
    }
    @media (max-width: 900px) {
      .trace-body2 { grid-template-columns: 1fr; }
    }

    /* â”€â”€ Left: graph â”€â”€ */
    .trace-graph2 {
      padding: 1rem 0.75rem;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .trace-graph2 svg { width: 100%; max-width: 260px; }
    .trace-graph2-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.62rem;
      color: var(--muted);
      text-align: center;
      margin-top: 0.3rem;
    }

    /* â”€â”€ Center: pseudocode + state â”€â”€ */
    .trace-center {
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border);
    }
    .pseudo-panel {
      flex: 1;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      overflow-y: auto;
    }
    .pseudo-panel-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      color: var(--muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }
    .pseudo-code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.76rem;
      line-height: 1.85;
      white-space: pre;
    }
    .pseudo-line {
      display: block;
      padding: 0 0.4rem;
      border-radius: 0.2rem;
      transition: background 0.2s, color 0.2s;
      color: #6a737d;
    }
    .pseudo-line.active {
      background: rgba(240,168,48,0.18);
      color: var(--amber);
      font-weight: 700;
    }
    .pseudo-line.done {
      color: rgba(63,185,80,0.6);
    }
    .pseudo-kw { color: #ff7b72; }
    .pseudo-fn { color: #d2a8ff; }
    .pseudo-cm { color: #6a737d; font-style: italic; }

    /* â”€â”€ State strip below pseudocode â”€â”€ */
    .state-strip2 {
      padding: 0.6rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .state-row2 {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.7rem;
    }
    .state-label2 {
      font-family: 'JetBrains Mono', monospace;
      color: var(--muted);
      width: 72px;
      flex-shrink: 0;
      font-size: 0.65rem;
    }
    .state-cells2 { display: flex; gap: 3px; flex-wrap: wrap; }
    .sc2 {
      width: 28px; height: 26px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.25rem;
      display: flex; align-items: center; justify-content: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      color: var(--muted);
      transition: all 0.2s;
    }
    .sc2.marked { background: rgba(63,185,80,0.18); border-color: var(--green); color: var(--green); }
    .sc2.current { background: rgba(240,168,48,0.22); border-color: var(--amber); color: var(--amber); box-shadow: 0 0 6px rgba(240,168,48,0.3); }

    /* â”€â”€ Right: call stack â”€â”€ */
    .call-stack-panel {
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
    }
    .call-stack-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      color: var(--muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }
    .call-stack-frames {
      flex: 1;
      display: flex;
      flex-direction: column-reverse;
      gap: 3px;
      justify-content: flex-end;
      min-height: 200px;
    }
    .stack-frame {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.35rem;
      padding: 0.35rem 0.6rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.25s;
      animation: stackIn 0.2s ease;
    }
    @keyframes stackIn { from { opacity:0; transform: translateX(8px); } }
    .stack-frame.top-frame {
      border-color: var(--amber);
      background: rgba(240,168,48,0.1);
      color: var(--amber);
    }
    .stack-frame-label { color: var(--teal); }
    .stack-frame-state { font-size: 0.6rem; color: var(--muted); }

    .stack-empty {
      text-align: center;
      color: #30363d;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
      padding: 2rem 0;
    }

    /* â”€â”€ Log strip at bottom â”€â”€ */
    .trace-log2 {
      border-top: 1px solid var(--border);
      padding: 0.6rem 1rem;
      max-height: 100px;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }
    .tl-entry {
      padding: 0.15rem 0;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      color: var(--muted);
    }
    .tl-entry.tl-mark { color: var(--green); }
    .tl-entry.tl-tree { color: var(--amber); }
    .tl-entry.tl-back { color: var(--coral); }
    .tl-entry.tl-call { color: var(--teal); }
    .tl-entry.tl-ret  { color: #58a6ff; }
    .tl-entry.tl-done { color: var(--violet); }
    .tl-entry.tl-active { font-weight: 700; }
  </style>

  <div class="trace-box2 scroll-reveal">
    <div class="trace-header2">
      <span class="trace-title2">DFS from vertex 0 â€” adj: 0[1,2,5] 1[0,2] 2[0,1,3,4] 3[2,4,5] 4[2,3] 5[0,3]</span>
      <div class="trace-controls2">
        <span class="step-counter" id="stepCount2">Step 0 / 25</span>
        <button class="btn2" id="resetBtn2" onclick="resetTrace2()">â†º Reset</button>
        <button class="btn2 primary2" id="nextBtn2" onclick="nextStep2()">Next Step â†’</button>
      </div>
    </div>

    <div class="trace-body2">

      <!-- LEFT: Graph SVG -->
      <div class="trace-graph2">
        <svg id="traceSvg2" viewBox="0 0 260 260" width="260" height="260">
          <!-- edges -->
          <line id="d01" x1="80" y1="95" x2="140" y2="48" stroke="#30363d" stroke-width="2"/>
          <line id="d02" x1="80" y1="95" x2="190" y2="95" stroke="#30363d" stroke-width="2"/>
          <line id="d05" x1="80" y1="95" x2="80" y2="205" stroke="#30363d" stroke-width="2"/>
          <line id="d12" x1="140" y1="48" x2="190" y2="95" stroke="#30363d" stroke-width="2"/>
          <line id="d23" x1="190" y1="95" x2="190" y2="170" stroke="#30363d" stroke-width="2"/>
          <line id="d24" x1="190" y1="95" x2="140" y2="205" stroke="#30363d" stroke-width="2"/>
          <line id="d34" x1="190" y1="170" x2="140" y2="205" stroke="#30363d" stroke-width="2"/>
          <line id="d35" x1="190" y1="170" x2="80"  y2="205" stroke="#30363d" stroke-width="2"/>
          <!-- nodes -->
          <circle cx="80"  cy="95"  r="24" fill="#161b22" stroke="#30363d" stroke-width="2" id="dc0"/>
          <text   x="80"  y="100" text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="13" id="dt0">0</text>
          <circle cx="140" cy="48"  r="24" fill="#161b22" stroke="#30363d" stroke-width="2" id="dc1"/>
          <text   x="140" y="53"  text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="13" id="dt1">1</text>
          <circle cx="190" cy="95"  r="24" fill="#161b22" stroke="#30363d" stroke-width="2" id="dc2"/>
          <text   x="190" y="100" text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="13" id="dt2">2</text>
          <circle cx="190" cy="170" r="24" fill="#161b22" stroke="#30363d" stroke-width="2" id="dc3"/>
          <text   x="190" y="175" text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="13" id="dt3">3</text>
          <circle cx="140" cy="205" r="24" fill="#161b22" stroke="#30363d" stroke-width="2" id="dc4"/>
          <text   x="140" y="210" text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="13" id="dt4">4</text>
          <circle cx="80"  cy="205" r="24" fill="#161b22" stroke="#30363d" stroke-width="2" id="dc5"/>
          <text   x="80"  y="210" text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="13" id="dt5">5</text>
        </svg>
        <div class="trace-graph2-label">Tree edges: amber &nbsp;|&nbsp; Back edges: red dashed</div>
      </div>

      <!-- CENTER: Pseudocode + State -->
      <div class="trace-center">
        <div class="pseudo-panel">
          <div class="pseudo-panel-title">Pseudocode â€” active line highlighted</div>
          <div class="pseudo-code" id="pseudoCode2">
<span class="pseudo-line" id="pl0"><span class="pseudo-fn">dfs</span>(Graph G, vertex v):</span>
<span class="pseudo-line" id="pl1">    marked[v] â† true          <span class="pseudo-cm">// â‘  MARK</span></span>
<span class="pseudo-line" id="pl2">    <span class="pseudo-kw">for each</span> neighbor w <span class="pseudo-kw">of</span> v:</span>
<span class="pseudo-line" id="pl3">        <span class="pseudo-kw">if</span> marked[w] = false:</span>
<span class="pseudo-line" id="pl4">            edgeTo[w] â† v     <span class="pseudo-cm">// â‘£ RECORD parent</span></span>
<span class="pseudo-line" id="pl5">            <span class="pseudo-fn">dfs</span>(G, w)          <span class="pseudo-cm">// â‘¤ DIVE deeper</span></span>
<span class="pseudo-line" id="pl6">        <span class="pseudo-kw">else</span>:                 <span class="pseudo-cm">// already marked</span></span>
<span class="pseudo-line" id="pl7">            <span class="pseudo-cm">// BACK EDGE or parent â€” skip</span></span>
<span class="pseudo-line" id="pl8">    <span class="pseudo-cm">// return â†’ auto backtrack</span></span>
          </div>
        </div>
        <div class="state-strip2">
          <div class="state-row2">
            <div class="state-label2">marked[]</div>
            <div class="state-cells2">
              <div class="sc2" id="sm0">F</div><div class="sc2" id="sm1">F</div><div class="sc2" id="sm2">F</div>
              <div class="sc2" id="sm3">F</div><div class="sc2" id="sm4">F</div><div class="sc2" id="sm5">F</div>
            </div>
          </div>
          <div class="state-row2">
            <div class="state-label2">edgeTo[]</div>
            <div class="state-cells2">
              <div class="sc2" id="se0">âˆ’</div><div class="sc2" id="se1">âˆ’</div><div class="sc2" id="se2">âˆ’</div>
              <div class="sc2" id="se3">âˆ’</div><div class="sc2" id="se4">âˆ’</div><div class="sc2" id="se5">âˆ’</div>
            </div>
          </div>
          <div class="state-row2" style="margin-top:0.25rem">
            <div class="state-label2">visit order</div>
            <div id="visitOrder2" style="font-family:'JetBrains Mono',monospace;font-size:0.65rem;color:var(--teal)">â€”</div>
          </div>
        </div>
      </div>

      <!-- RIGHT: Call Stack -->
      <div class="call-stack-panel">
        <div class="call-stack-title">ğŸ“š Call Stack</div>
        <div class="call-stack-frames" id="callStack2">
          <div class="stack-empty" id="stackEmpty2">empty</div>
        </div>
      </div>

    </div><!-- /trace-body2 -->

    <!-- Log strip -->
    <div class="trace-log2" id="traceLog2">
      <div class="tl-entry">ğŸš€ Press "Next Step" to start DFS from vertex 0.</div>
    </div>

  </div><!-- /trace-box2 -->

  <!-- â”€â”€ ITERATIVE DFS â”€â”€ -->
  <h3>Iterative DFS â€” Using an Explicit Stack</h3>
  <p>Recursive DFS uses the <em>call stack</em> implicitly. For very large graphs (millions of vertices), this can overflow. The iterative version replaces it with our own explicit stack.</p>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· Iterative DFS (Explicit Stack)</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Iterative DFS: same algorithm, but uses an explicit stack
 instead of relying on the system call stack.
 This avoids stack overflow on very large graphs (millions of nodes).

 KEY DIFFERENCE from recursive:
   A vertex may be pushed multiple times (once per discovering neighbor).
   We check marked[] right after popping and skip if already visited.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="fn">dfsIterative</span>(Graph G, vertex s):
    marked[0..V-1] â† all false
    edgeTo[0..V-1] â† all -1

    S â† new empty stack
    S.push(s)                      <span class="cm">// seed the stack with the source</span>

    <span class="kw">while</span> S is not empty:

        v â† S.pop()                <span class="cm">// take the most recently pushed vertex</span>

        <span class="kw">if</span> marked[v] = true:
            continue               <span class="cm">// already processed (was pushed more than once) â†’ skip</span>

        marked[v] â† true           <span class="cm">// first visit â†’ claim it now</span>

        <span class="kw">for each</span> neighbor w <span class="kw">of</span> v (in reverse order):
            <span class="cm">// reverse order â†’ LIFO stack gives left-to-right processing</span>
            <span class="cm">// matching the order the recursive version would visit</span>
            <span class="kw">if</span> marked[w] = false:
                edgeTo[w] â† v     <span class="cm">// record parent (tentative â€” first write wins)</span>
                S.push(w)         <span class="cm">// schedule w for future processing</span>

    <span class="cm">// Stack empty â†’ all vertices reachable from s have been visited</span></pre>
  </div>

  <div class="compare-strip scroll-reveal">
    <div class="compare-side">
      <h4>ğŸŒ€ Recursive DFS</h4>
      <ul>
        <li>Elegant and concise â€” the function call IS the stack push</li>
        <li>Backtracking is automatic (happens when dfs() returns)</li>
        <li>Uses the <em>system call stack</em> implicitly</li>
        <li>Stack depth = longest DFS path = up to O(V) frames</li>
        <li>âš ï¸ Can crash on very deep graphs (stack overflow with ~10Kâ€“100K depth)</li>
        <li>Best for: teaching, small/medium graphs, competitive programming</li>
      </ul>
    </div>
    <div class="compare-side">
      <h4>ğŸ“š Iterative DFS</h4>
      <ul>
        <li>Uses an <em>explicit stack</em> data structure (on the heap)</li>
        <li>Heap memory is virtually unlimited â€” no stack overflow</li>
        <li>May push the same vertex multiple times (needs duplicate check)</li>
        <li>Slightly more code, but production-safe</li>
        <li>Same O(V+E) time and space complexity as recursive</li>
        <li>Best for: large graphs, production code, social network analysis</li>
      </ul>
    </div>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§6  DFS APPLICATIONS -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-apps">
<div class="container">
  <span class="section-num">SECTION 06</span>
  <h2 class="section-title">What DFS Can Do</h2>
  <p>A single linear-time DFS traversal can solve many problems. The key insight is that DFS visits every reachable vertex exactly once, and along the way it builds up two data structures â€” <span class="inline-mono">marked[]</span> and <span class="inline-mono">edgeTo[]</span> â€” that contain a surprising amount of information. Different algorithms simply use that information in different ways.</p>

  <div class="callout scroll-reveal">
    <span class="callout-label">The Pattern</span>
    <p>Every DFS-based algorithm follows the same recipe: <strong>(1) Run DFS once</strong> from the relevant starting vertex, collecting extra bookkeeping data during traversal. <strong>(2) Answer queries</strong> from that precomputed data in O(1) time. The heavy work happens once at construction time; after that, every question is cheap.</p>
  </div>

  <!-- â”€â”€ PATH FINDING â”€â”€ -->
  <h3>Application 1: Finding Paths</h3>
  <p>The <span class="inline-mono">edgeTo[]</span> array is a <em>parent-link tree</em>. To reconstruct the path from source <span class="inline-mono">s</span> to any vertex <span class="inline-mono">v</span>, just follow parent pointers back to <span class="inline-mono">s</span>.</p>

  <div class="callout amber scroll-reveal">
    <span class="callout-label">What is edgeTo[]?</span>
    <p><span class="inline-mono">edgeTo[v] = u</span> means: <em>"The first time DFS discovered vertex v, it came from vertex u."</em></p>
    <p style="margin-top:0.5rem">All the <span class="inline-mono">edgeTo[]</span> entries together form a tree rooted at the source. This "parent-link tree" is essentially a road map showing how DFS traveled the graph. To find the path from source to any vertex v, walk the tree backwards from v to the root:</p>
    <p style="margin-top:0.5rem;font-family:'JetBrains Mono',monospace;font-size:0.85rem">v â†’ edgeTo[v] â†’ edgeTo[edgeTo[v]] â†’ ... â†’ source</p>
    <p style="margin-top:0.5rem">Then reverse that list to get source â†’ ... â†’ v.</p>
  </div>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 220" width="700" height="220">
      <!-- DFS tree from section trace -->
      <line x1="100" y1="110" x2="200" y2="60" stroke="#f0a830" stroke-width="2.5"/>
      <line x1="200" y1="60" x2="300" y2="110" stroke="#f0a830" stroke-width="2.5"/>
      <line x1="300" y1="110" x2="400" y2="60" stroke="#f0a830" stroke-width="2.5"/>
      <line x1="400" y1="60" x2="490" y2="110" stroke="#f0a830" stroke-width="2.5"/>
      <line x1="400" y1="60" x2="490" y2="170" stroke="#f0a830" stroke-width="2.5"/>

      <!-- PATH to vertex 5: highlighted -->
      <line x1="100" y1="110" x2="200" y2="60" stroke="#39d0d8" stroke-width="4" opacity="0.8"/>
      <line x1="200" y1="60" x2="300" y2="110" stroke="#39d0d8" stroke-width="4" opacity="0.8"/>
      <line x1="300" y1="110" x2="400" y2="60" stroke="#39d0d8" stroke-width="4" opacity="0.8"/>
      <line x1="400" y1="60" x2="490" y2="170" stroke="#39d0d8" stroke-width="4" opacity="0.8"/>

      <!-- nodes -->
      <circle cx="100" cy="110" r="26" fill="rgba(57,208,216,0.2)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="100" y="105" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">0</text>
      <text x="100" y="120" text-anchor="middle" fill="#39d0d8" font-family="Nunito" font-size="9">source</text>

      <circle cx="200" cy="60" r="26" fill="rgba(57,208,216,0.1)" stroke="#39d0d8" stroke-width="2"/>
      <text x="200" y="65" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">1</text>

      <circle cx="300" cy="110" r="26" fill="rgba(57,208,216,0.1)" stroke="#39d0d8" stroke-width="2"/>
      <text x="300" y="115" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">2</text>

      <circle cx="400" cy="60" r="26" fill="rgba(57,208,216,0.1)" stroke="#39d0d8" stroke-width="2"/>
      <text x="400" y="65" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="13">3</text>

      <circle cx="490" cy="110" r="26" fill="rgba(240,168,48,0.1)" stroke="#f0a830" stroke-width="2"/>
      <text x="490" y="115" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="13">4</text>

      <circle cx="490" cy="170" r="26" fill="rgba(255,107,107,0.2)" stroke="#ff6b6b" stroke-width="2.5"/>
      <text x="490" y="165" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="13">5</text>
      <text x="490" y="180" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="9">target</text>

      <!-- edgeTo labels -->
      <text x="150" y="70" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="9">edgeTo[1]=0</text>
      <text x="250" y="95" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="9">edgeTo[2]=1</text>
      <text x="350" y="70" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="9">edgeTo[3]=2</text>
      <text x="450" y="130" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="9">edgeTo[5]=3</text>

      <text x="350" y="205" text-anchor="middle" fill="#39d0d8" font-family="Nunito" font-size="12">Path from 0 to 5: follow edgeTo backwards â†’ 5â†3â†2â†1â†0 â†’ reverse â†’ 0â†’1â†’2â†’3â†’5</text>
    </svg>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· DepthFirstPaths Class</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 DepthFirstPaths â€” Constructor-Query Pattern:
   STEP 1 (Constructor): Run DFS once from s. O(V+E) time.
                         Fill in marked[] and edgeTo[].
   STEP 2 (Queries):     Answer hasPathTo / pathTo in O(1) or
                         O(path length) using precomputed data.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="kw">class</span> <span class="ty">DepthFirstPaths</span>:

    <span class="cm">â”€â”€ Private state (computed once, queried many times) â”€â”€</span>
    marked[0..V-1]  <span class="cm">// marked[v] = true â†’ v is reachable from source s</span>
    edgeTo[0..V-1]  <span class="cm">// edgeTo[v] = u â†’ "the DFS tree edge to v came from u"</span>
    source          <span class="cm">// the vertex s we started from</span>

    <span class="cm">â”€â”€ Constructor â€” O(V + E) one-time cost â”€â”€</span>
    <span class="fn">DepthFirstPaths</span>(Graph G, vertex s):
        source  â† s
        marked  â† all false
        edgeTo  â† all -1
        <span class="fn">dfs</span>(G, s)            <span class="cm">// populates marked[] and edgeTo[]</span>

    <span class="cm">â”€â”€ Private: standard recursive DFS â”€â”€</span>
    <span class="fn">dfs</span>(Graph G, vertex v):
        marked[v] â† true
        <span class="kw">for each</span> neighbor w <span class="kw">of</span> v:
            <span class="kw">if</span> marked[w] = false:
                edgeTo[w] â† v    <span class="cm">// "the edge vâ†’w discovered w"</span>
                <span class="fn">dfs</span>(G, w)

    <span class="cm">â”€â”€ Public query methods â”€â”€</span>

    <span class="fn">hasPathTo</span>(vertex v) â†’ boolean:           <span class="cm">// O(1)</span>
        return marked[v]

    <span class="fn">pathTo</span>(vertex v) â†’ sequence of vertices:  <span class="cm">// O(path length)</span>
        <span class="kw">if</span> hasPathTo(v) = false: return empty

        path â† empty list
        x â† v
        <span class="kw">while</span> x â‰  source:
            prepend x to path        <span class="cm">// walk backwards through edgeTo[]</span>
            x â† edgeTo[x]           <span class="cm">// e.g. edgeTo[5]=3 â†’ edgeTo[3]=2 â†’ edgeTo[2]=1 â†’ edgeTo[1]=0</span>
        prepend source to path
        return path                  <span class="cm">// result: source â†’ ... â†’ v</span>

<span class="cm">â”€â”€ Usage â”€â”€</span>
dfp â† <span class="kw">new</span> <span class="ty">DepthFirstPaths</span>(G, 0)    <span class="cm">// one-time O(V+E) preprocessing</span>
<span class="fn">dfp.hasPathTo</span>(5)                    <span class="cm">// O(1) â†’ true</span>
<span class="fn">dfp.pathTo</span>(5)                       <span class="cm">// O(path) â†’ [0, 1, 2, 3, 5]</span></pre>
  </div>

  <div class="callout coral scroll-reveal">
    <span class="callout-label">âš ï¸ DFS finds <em>a</em> path, not the <em>shortest</em> path</span>
    <p>DFS follows its nose â€” it dives deep along whatever path it happens to explore first. It might return path 0â†’1â†’2â†’3â†’5 even though edge {0,5} exists (a direct single-hop path!). DFS is not trying to minimize anything. It just wants to <em>reach</em> the destination.</p>
    <p style="margin-top:0.75rem">For shortest paths in <strong>unweighted graphs</strong>, use <strong>Breadth-First Search (BFS)</strong> â€” covered in the next lecture. BFS explores vertices level by level (all distance-1 neighbors first, then distance-2, etc.), which guarantees the shortest path is found first.</p>
    <p style="margin-top:0.75rem;font-family:'JetBrains Mono',monospace;font-size:0.8rem;color:var(--muted)">Rule: DFS = "find A path"  |  BFS = "find the SHORTEST path"</p>
  </div>

  <!-- â”€â”€ CONNECTED COMPONENTS â”€â”€ -->
  <h3>Application 2: Connected Components</h3>
  <p>A connected component is an "island" of the graph â€” a maximal set of vertices where every pair is reachable from every other. If you can walk between two vertices, they're in the same component. DFS finds all components in a single O(V+E) pass.</p>

  <p>The trick: we add a counter that increments after each top-level DFS call. Every vertex labeled during a single DFS call gets the same component number. After processing all vertices, any two vertices with the same component number are connected â€” and answering that question costs just a single integer comparison: O(1).</p>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 240" width="700" height="240">
      <!-- Component 0 -->
      <rect x="30" y="30" width="220" height="180" rx="12" fill="rgba(57,208,216,0.04)" stroke="rgba(57,208,216,0.2)" stroke-width="1.5" stroke-dasharray="6,4"/>
      <text x="140" y="22" text-anchor="middle" fill="#39d0d8" font-family="Nunito" font-size="12" font-weight="700">Component 0</text>
      <line x1="80" y1="100" x2="160" y2="60" stroke="#39d0d8" stroke-width="2"/>
      <line x1="80" y1="100" x2="160" y2="140" stroke="#39d0d8" stroke-width="2"/>
      <line x1="160" y1="60" x2="220" y2="100" stroke="#39d0d8" stroke-width="2"/>
      <line x1="160" y1="140" x2="220" y2="100" stroke="#39d0d8" stroke-width="2"/>
      <circle cx="80" cy="100" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="80" y="105" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">0</text>
      <circle cx="160" cy="60" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="160" y="65" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">1</text>
      <circle cx="160" cy="140" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="160" y="145" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">2</text>
      <circle cx="220" cy="100" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="220" y="105" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">3</text>
      <text x="140" y="200" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="10">id[] = 0</text>

      <!-- Component 1 -->
      <rect x="290" y="60" width="120" height="120" rx="12" fill="rgba(240,168,48,0.04)" stroke="rgba(240,168,48,0.2)" stroke-width="1.5" stroke-dasharray="6,4"/>
      <text x="350" y="52" text-anchor="middle" fill="#f0a830" font-family="Nunito" font-size="12" font-weight="700">Component 1</text>
      <line x1="320" y1="120" x2="380" y2="120" stroke="#f0a830" stroke-width="2"/>
      <circle cx="320" cy="120" r="22" fill="#0d1117" stroke="#f0a830" stroke-width="2"/>
      <text x="320" y="125" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="12">4</text>
      <circle cx="380" cy="120" r="22" fill="#0d1117" stroke="#f0a830" stroke-width="2"/>
      <text x="380" y="125" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="12">5</text>
      <text x="350" y="200" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="10">id[] = 1</text>

      <!-- Component 2 -->
      <rect x="450" y="30" width="220" height="180" rx="12" fill="rgba(167,139,250,0.04)" stroke="rgba(167,139,250,0.2)" stroke-width="1.5" stroke-dasharray="6,4"/>
      <text x="560" y="22" text-anchor="middle" fill="#a78bfa" font-family="Nunito" font-size="12" font-weight="700">Component 2</text>
      <line x1="490" y1="100" x2="560" y2="60" stroke="#a78bfa" stroke-width="2"/>
      <line x1="490" y1="100" x2="560" y2="140" stroke="#a78bfa" stroke-width="2"/>
      <line x1="560" y1="60" x2="630" y2="100" stroke="#a78bfa" stroke-width="2"/>
      <line x1="560" y1="140" x2="630" y2="100" stroke="#a78bfa" stroke-width="2"/>
      <line x1="560" y1="60" x2="560" y2="140" stroke="#a78bfa" stroke-width="2" stroke-dasharray="4,3"/>
      <circle cx="490" cy="100" r="22" fill="#0d1117" stroke="#a78bfa" stroke-width="2"/>
      <text x="490" y="105" text-anchor="middle" fill="#a78bfa" font-family="JetBrains Mono" font-size="12">6</text>
      <circle cx="560" cy="60" r="22" fill="#0d1117" stroke="#a78bfa" stroke-width="2"/>
      <text x="560" y="65" text-anchor="middle" fill="#a78bfa" font-family="JetBrains Mono" font-size="12">7</text>
      <circle cx="560" cy="140" r="22" fill="#0d1117" stroke="#a78bfa" stroke-width="2"/>
      <text x="560" y="145" text-anchor="middle" fill="#a78bfa" font-family="JetBrains Mono" font-size="12">8</text>
      <circle cx="630" cy="100" r="22" fill="#0d1117" stroke="#a78bfa" stroke-width="2"/>
      <text x="630" y="105" text-anchor="middle" fill="#a78bfa" font-family="JetBrains Mono" font-size="12">9</text>
      <text x="560" y="200" text-anchor="middle" fill="#6a737d" font-family="JetBrains Mono" font-size="10">id[] = 2</text>
    </svg>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· ConnectedComponents Class</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ConnectedComponents â€” run DFS once per component.

 Key insight: add an id[] array.
   id[v] = which component (0, 1, 2, ...) does v belong to?

 All vertices in the same component get the same id number.
 After preprocessing:  v and w are connected â†” id[v] = id[w]
 That check is O(1) â€” just compare two integers!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="kw">class</span> <span class="ty">ConnectedComponents</span>:

    marked[0..V-1] â† all false
    id[0..V-1]                   <span class="cm">// id[v] = component number of v</span>
    count â† 0                   <span class="cm">// how many components found so far</span>

    <span class="cm">â”€â”€ Constructor: find all components in O(V+E) â”€â”€</span>
    <span class="fn">ConnectedComponents</span>(Graph G):
        <span class="kw">for</span> v <span class="kw">in</span> 0..V-1:
            <span class="kw">if</span> marked[v] = false:
                <span class="fn">dfs</span>(G, v)          <span class="cm">// explore and label this entire component</span>
                count â† count + 1  <span class="cm">// finished one component â†’ increment for next</span>

    <span class="cm">â”€â”€ Private: DFS that stamps each vertex with current component id â”€â”€</span>
    <span class="fn">dfs</span>(Graph G, vertex v):
        marked[v] â† true
        id[v] â† count             <span class="cm">// label v with current component number</span>
        <span class="kw">for each</span> neighbor w <span class="kw">of</span> v:
            <span class="kw">if</span> marked[w] = false:
                <span class="fn">dfs</span>(G, w)         <span class="cm">// spread same 'count' label to all reachable vertices</span>

    <span class="cm">â”€â”€ Public queries â€” all O(1) â”€â”€</span>
    <span class="fn">connected</span>(u, w) â†’ boolean: return id[u] = id[w]   <span class="cm">// same component?</span>
    <span class="fn">componentId</span>(v) â†’ integer:  return id[v]
    <span class="fn">numComponents</span>() â†’ integer: return count

<span class="cm">â”€â”€ Usage: O(V+E) one-time setup, then O(1) per query â”€â”€</span>
cc â† <span class="kw">new</span> <span class="ty">ConnectedComponents</span>(G)
<span class="fn">cc.numComponents</span>()      <span class="cm">// â†’ 3</span>
<span class="fn">cc.connected</span>(0, 3)      <span class="cm">// â†’ true  (both in component 0)</span>
<span class="fn">cc.connected</span>(0, 4)      <span class="cm">// â†’ false (different components)</span></pre>
  </div>

  <!-- â”€â”€ CYCLE DETECTION â”€â”€ -->
  <h3>Application 3: Cycle Detection</h3>
  <p>A cycle exists when DFS encounters a neighbor that is <em>already marked but is not its direct parent</em>. This is called a <span class="highlight">back edge</span> â€” an edge that "goes back" to an ancestor in the DFS tree, forming a loop.</p>

  <p>The most subtle part of this algorithm is why we need the <strong>parent check</strong>. Here's the problem: in an undirected graph, every edge {u,v} appears in both adjacency lists â€” once as u's neighbor and once as v's. When DFS travels from u to v, it will immediately see u listed as one of v's neighbors. Without checking, DFS would think it found a cycle (vâ†’uâ†’v). But that's not a cycle â€” it's just the same edge we used to arrive! We skip it by comparing each neighbor against our parent.</p>

  <div class="callout amber scroll-reveal">
    <span class="callout-label">Why Check for Parent?</span>
    <p>In an undirected graph, every edge {u,v} appears in <em>both</em> adjacency lists. When DFS visits v from u, it will later see u in v's adjacency list. Without a parent check, we'd falsely report a cycle of length 2. The <span class="inline-mono">parent</span> parameter tells us: "ignore the vertex we just came from."</p>
  </div>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 240" width="700" height="240">
      <!-- no-cycle example -->
      <text x="175" y="20" text-anchor="middle" fill="#3fb950" font-family="Nunito" font-size="13" font-weight="700">âœ“ No Cycle (path graph)</text>
      <line x1="60" y1="120" x2="130" y2="120" stroke="#39d0d8" stroke-width="2"/>
      <line x1="130" y1="120" x2="200" y2="120" stroke="#39d0d8" stroke-width="2"/>
      <line x1="200" y1="120" x2="270" y2="120" stroke="#39d0d8" stroke-width="2"/>
      <circle cx="60" cy="120" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="60" y="125" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">0</text>
      <circle cx="130" cy="120" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="130" y="125" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">1</text>
      <circle cx="200" cy="120" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="200" y="125" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">2</text>
      <circle cx="270" cy="120" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="270" y="125" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">3</text>
      <text x="165" y="175" text-anchor="middle" fill="#3fb950" font-family="Nunito" font-size="11">DFS finds no back edge â†’ acyclic</text>

      <!-- divider -->
      <line x1="350" y1="20" x2="350" y2="230" stroke="#30363d" stroke-width="1" stroke-dasharray="5,4"/>

      <!-- cycle example -->
      <text x="535" y="20" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="13" font-weight="700">âœ— Has Cycle</text>
      <line x1="420" y1="80" x2="520" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <line x1="520" y1="80" x2="620" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <line x1="420" y1="80" x2="420" y2="170" stroke="#39d0d8" stroke-width="2"/>
      <line x1="420" y1="170" x2="520" y2="170" stroke="#39d0d8" stroke-width="2"/>
      <line x1="520" y1="170" x2="620" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <!-- back edge (the one that closes the cycle) -->
      <line x1="620" y1="80" x2="420" y2="80" stroke="#ff6b6b" stroke-width="3" stroke-dasharray="6,3" opacity="0.7"/>
      <text x="520" y="50" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="10">back edge â†’ CYCLE!</text>
      <circle cx="420" cy="80" r="22" fill="rgba(255,107,107,0.1)" stroke="#ff6b6b" stroke-width="2"/>
      <text x="420" y="85" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="12">0</text>
      <circle cx="520" cy="80" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="520" y="85" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">1</text>
      <circle cx="620" cy="80" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="620" y="85" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">2</text>
      <circle cx="420" cy="170" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="420" y="175" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">3</text>
      <circle cx="520" cy="170" r="22" fill="#0d1117" stroke="#39d0d8" stroke-width="2"/>
      <text x="520" y="175" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">4</text>
      <text x="520" y="210" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="11">DFS from 2 sees 0 is marked (not parent) â†’ cycle!</text>
    </svg>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· CycleDetection Class</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 CycleDetection: a cycle exists if DFS finds a "back edge" â€”
 a neighbor w that is already marked AND is not our direct parent.

 Why check "w â‰  parent"?
   In an undirected graph, edge {v,w} is in BOTH adj lists.
   When DFS goes vâ†’w, it will later see v in w's neighbor list.
   Without the parent check, we'd falsely report the 2-hop
   "cycle" vâ†’wâ†’v â€” but that's just the same edge seen twice!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="kw">class</span> <span class="ty">CycleDetection</span>:

    marked[0..V-1] â† all false
    hasCycle â† false

    <span class="cm">â”€â”€ Constructor: check all components â”€â”€</span>
    <span class="fn">CycleDetection</span>(Graph G):
        <span class="kw">for</span> v <span class="kw">in</span> 0..V-1:
            <span class="kw">if</span> marked[v] = false:
                <span class="fn">dfs</span>(G, v, parent=-1)   <span class="cm">// source has no parent</span>

    <span class="cm">â”€â”€ Private: DFS with parent tracking â”€â”€</span>
    <span class="fn">dfs</span>(Graph G, vertex v, vertex parent):
        marked[v] â† true

        <span class="kw">for each</span> neighbor w <span class="kw">of</span> v:

            <span class="kw">if</span> marked[w] = false:
                <span class="fn">dfs</span>(G, w, parent=v)    <span class="cm">// normal tree edge â†’ recurse, v is w's parent</span>

            <span class="kw">else if</span> w â‰  parent:       <span class="cm">// w IS marked AND not our parent</span>
                hasCycle â† true        <span class="cm">// BACK EDGE â†’ cycle found!</span>
                                       <span class="cm">// (w is an ancestor we reached a different way)</span>

            <span class="cm">// if w = parent: just the edge we came from â†’ ignore (not a cycle)</span>

    <span class="fn">containsCycle</span>() â†’ boolean: return hasCycle</pre>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§7  EDGE CLASSIFICATION -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-edges">
<div class="container">
  <span class="section-num">SECTION 07</span>
  <h2 class="section-title">Edge Classification</h2>
  <p>When DFS runs on a graph, it divides every edge into categories based on what role it plays in the traversal. Understanding edge types is crucial for advanced algorithms.</p>

  <h3>In Undirected Graphs â€” Two Types Only</h3>

  <div class="card-grid scroll-reveal">
    <div class="card">
      <h4><span class="edge-badge tree">TREE EDGE</span></h4>
      <p>An edge that DFS uses to discover a new vertex for the first time. These edges form the <strong>DFS tree</strong>. If we took all tree edges together, they'd span the entire connected component.</p>
      <p style="margin-top:0.5rem;font-size:0.85rem;color:var(--muted)">Recorded in edgeTo[]. Count: exactly Vâˆ’1 for a connected graph.</p>
    </div>
    <div class="card">
      <h4><span class="edge-badge back">BACK EDGE</span></h4>
      <p>An edge connecting a vertex to an <strong>ancestor</strong> in the DFS tree (a vertex already visited above us in the recursion). Every back edge creates a cycle.</p>
      <p style="margin-top:0.5rem;font-size:0.85rem;color:var(--muted)">Count: E âˆ’ (Vâˆ’1) for a connected graph.</p>
    </div>
  </div>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 340" width="700" height="340">
      <text x="350" y="22" text-anchor="middle" fill="#8b949e" font-family="Nunito" font-size="13">DFS from vertex 0 â€” tree edges in amber, back edges in red</text>

      <!-- TREE EDGES (amber) -->
      <line x1="350" y1="60" x2="200" y2="130" stroke="#f0a830" stroke-width="3"/>
      <line x1="200" y1="130" x2="200" y2="210" stroke="#f0a830" stroke-width="3"/>
      <line x1="200" y1="210" x2="350" y2="275" stroke="#f0a830" stroke-width="3"/>
      <line x1="350" y1="275" x2="500" y2="210" stroke="#f0a830" stroke-width="3"/>

      <!-- BACK EDGES (red dashed) -->
      <line x1="350" y1="60" x2="500" y2="130" stroke="#ff6b6b" stroke-width="2.5" stroke-dasharray="8,4"/>
      <line x1="500" y1="130" x2="500" y2="210" stroke="#ff6b6b" stroke-width="2.5" stroke-dasharray="8,4"/>

      <!-- nodes -->
      <circle cx="350" cy="60" r="30" fill="rgba(57,208,216,0.15)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="350" y="55" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="14">0</text>
      <text x="350" y="72" text-anchor="middle" fill="#39d0d8" font-family="Nunito" font-size="9">start</text>

      <circle cx="200" cy="130" r="28" fill="#0d1117" stroke="#f0a830" stroke-width="2"/>
      <text x="200" y="135" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="14">1</text>

      <circle cx="500" cy="130" r="28" fill="#0d1117" stroke="#ff6b6b" stroke-width="2"/>
      <text x="500" y="135" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="14">2</text>

      <circle cx="200" cy="210" r="28" fill="#0d1117" stroke="#f0a830" stroke-width="2"/>
      <text x="200" y="215" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="14">3</text>

      <circle cx="500" cy="210" r="28" fill="#0d1117" stroke="#ff6b6b" stroke-width="2"/>
      <text x="500" y="215" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="14">4</text>

      <circle cx="350" cy="275" r="28" fill="#0d1117" stroke="#f0a830" stroke-width="2"/>
      <text x="350" y="280" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="14">5</text>

      <!-- labels -->
      <text x="220" y="170" fill="#f0a830" font-family="Nunito" font-size="10">tree edge</text>
      <text x="515" y="170" fill="#ff6b6b" font-family="Nunito" font-size="10">back edges</text>
      <text x="245" y="250" fill="#f0a830" font-family="Nunito" font-size="10">tree edge</text>
      <text x="390" y="250" fill="#f0a830" font-family="Nunito" font-size="10">tree edge</text>

      <!-- count summary -->
      <text x="350" y="320" text-anchor="middle" fill="#8b949e" font-family="JetBrains Mono" font-size="11">6 vertices Â· 7 edges total Â· 5 tree edges (V-1) Â· 2 back edges (E-(V-1))</text>
    </svg>
  </div>

  <h3>In Directed Graphs â€” Four Types</h3>
  <p>Directed graphs have two additional edge types. DFS uses <em>discovery times</em> and <em>finish times</em> (vertex states: white/gray/black) to distinguish them:</p>

  <div class="card-grid scroll-reveal">
    <div class="card">
      <h4><span class="edge-badge tree">TREE EDGE</span></h4>
      <p>Same as undirected: the edge used to discover a new vertex. Forms the DFS tree.</p>
    </div>
    <div class="card">
      <h4><span class="edge-badge back">BACK EDGE</span></h4>
      <p>From a vertex to one of its <em>ancestors</em> (a still-gray/open vertex). These indicate <strong>cycles</strong> in directed graphs.</p>
    </div>
    <div class="card">
      <h4><span class="edge-badge forward">FORWARD EDGE</span></h4>
      <p>From a vertex to one of its <em>descendants</em> in the DFS tree (but not the direct child). A "shortcut" edge. Only in digraphs.</p>
    </div>
    <div class="card">
      <h4><span class="edge-badge cross">CROSS EDGE</span></h4>
      <p>An edge between vertices in different DFS subtrees, or to a completely finished subtree. Only in digraphs.</p>
    </div>
  </div>

  <div class="callout green scroll-reveal">
    <span class="callout-label">Key Theorem</span>
    <p>In an undirected graph, DFS produces <strong>only tree edges and back edges</strong> â€” no forward or cross edges. This is because when DFS at vertex u sees an already-visited neighbor v, v must be an ancestor (still on the recursion stack). If v were in a different subtree, DFS would have found it via u instead.</p>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§8  DESIGN PATTERN -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-design">
<div class="container">
  <span class="section-num">SECTION 08</span>
  <h2 class="section-title">Software Design: Separating Data from Algorithms</h2>
  <p>Sedgewick's key insight: keep the <em>graph data structure</em> completely separate from the <em>algorithms that process it</em>. The <span class="inline-mono">Graph</span> class only stores vertices and edges â€” it never "knows" about paths, components, or cycles. Every algorithm lives in its own class.</p>

  <p>Think of it like a database vs queries: the database just holds data. SQL queries process it without modifying the schema. Same idea here â€” <span class="inline-mono">Graph</span> is the database; <span class="inline-mono">DepthFirstPaths</span>, <span class="inline-mono">ConnectedComponents</span>, etc. are the queries.</p>

  <div class="callout scroll-reveal">
    <span class="callout-label">The Constructor-Query Pattern â€” Used in Every DFS Class</span>
    <p><strong>Constructor:</strong> Receives a <span class="inline-mono">Graph</span> (and possibly a source vertex), runs the full algorithm in O(V+E), and stores results in member variables.</p>
    <p style="margin-top:0.5rem"><strong>Query methods:</strong> Answer specific questions in O(1) (or at worst O(path length)) by reading from precomputed member variables. No graph traversal happens during queries.</p>
    <p style="margin-top:0.5rem">This is the power of preprocessing: pay O(V+E) once, then answer thousands of queries instantly.</p>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· Complete DFS Library</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 The complete DFS library â€” constructor-query pattern for all uses.
 Each class runs DFS once in its constructor, then answers O(1)
 queries from precomputed arrays.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="cm">â”€â”€ Graph class: stores data only, knows nothing about algorithms â”€â”€</span>
<span class="kw">class</span> <span class="ty">Graph</span>:
    V, E: integer
    adj[0..V-1]: list of neighbors
    <span class="fn">Graph</span>(V): Vâ†V, Eâ†0, adjâ†V empty lists
    <span class="fn">addEdge</span>(u,v): adj[u].append(v); adj[v].append(u); Eâ†E+1
    <span class="fn">neighbors</span>(v): return adj[v]
    <span class="fn">numVertices</span>(): return V

<span class="cm">â”€â”€ DepthFirstPaths: find paths from source s â”€â”€</span>
<span class="kw">class</span> <span class="ty">DepthFirstPaths</span>:
    marked[], edgeTo[], source
    <span class="fn">DepthFirstPaths</span>(G, s): initialize arrays; <span class="fn">dfs</span>(G, s)
    <span class="fn">hasPathTo</span>(v): return marked[v]          <span class="cm">// O(1)</span>
    <span class="fn">pathTo</span>(v): walk edgeTo[] backwards       <span class="cm">// O(path length)</span>

<span class="cm">â”€â”€ ConnectedComponents: label every vertex with its component id â”€â”€</span>
<span class="kw">class</span> <span class="ty">ConnectedComponents</span>:
    marked[], id[], countâ†0
    <span class="fn">ConnectedComponents</span>(G): <span class="kw">for</span> each v: <span class="kw">if</span> !marked[v]: <span class="fn">dfs</span>(G,v); count++
    <span class="fn">connected</span>(u,w): return id[u] = id[w]   <span class="cm">// O(1)</span>
    <span class="fn">numComponents</span>(): return count           <span class="cm">// O(1)</span>

<span class="cm">â”€â”€ CycleDetection: does the graph have any cycle? â”€â”€</span>
<span class="kw">class</span> <span class="ty">CycleDetection</span>:
    marked[], hasCycleâ†false
    <span class="fn">CycleDetection</span>(G): <span class="kw">for</span> each v: <span class="kw">if</span> !marked[v]: <span class="fn">dfs</span>(G,v,parent=-1)
    <span class="fn">containsCycle</span>(): return hasCycle        <span class="cm">// O(1)</span>

<span class="cm">â”€â”€ BipartiteTest: can vertices be 2-colored? â”€â”€</span>
<span class="kw">class</span> <span class="ty">BipartiteTest</span>:
    marked[], color[], isBipartiteâ†true
    <span class="fn">BipartiteTest</span>(G): <span class="kw">for</span> each v: <span class="kw">if</span> !marked[v]: <span class="fn">dfs</span>(G,v)
    <span class="fn">isBipartite</span>(): return isBipartite       <span class="cm">// O(1)</span>

<span class="cm">â”€â”€ Usage: one-time O(V+E) construction, then O(1) per query â”€â”€</span>
G â† <span class="kw">new</span> <span class="ty">Graph</span>(10)
G.<span class="fn">addEdge</span>(0,1)  G.<span class="fn">addEdge</span>(0,5)  G.<span class="fn">addEdge</span>(1,2)  <span class="cm">// ... etc</span>

dfp â† <span class="kw">new</span> <span class="ty">DepthFirstPaths</span>(G, 0)
<span class="fn">dfp.hasPathTo</span>(5)          <span class="cm">// O(1) â†’ true</span>
<span class="fn">dfp.pathTo</span>(5)             <span class="cm">// O(len) â†’ [0, 1, 2, 3, 5]</span>

cc â† <span class="kw">new</span> <span class="ty">ConnectedComponents</span>(G)
<span class="fn">cc.numComponents</span>()        <span class="cm">// O(1) â†’ 1  (all connected)</span>
<span class="fn">cc.connected</span>(0, 9)        <span class="cm">// O(1) â†’ true / false</span>

cd â† <span class="kw">new</span> <span class="ty">CycleDetection</span>(G)
<span class="fn">cd.containsCycle</span>()        <span class="cm">// O(1) â†’ true</span>

bip â† <span class="kw">new</span> <span class="ty">BipartiteTest</span>(G)
<span class="fn">bip.isBipartite</span>()         <span class="cm">// O(1) â†’ false (has odd cycle)</span></pre>
  </div>

  <div class="card-grid scroll-reveal">
    <div class="card">
      <span class="card-icon">ğŸ¯</span>
      <h4>Single Responsibility</h4>
      <p>Graph stores data. Each processing class solves one problem. Clean, focused code.</p>
    </div>
    <div class="card">
      <span class="card-icon">â™»ï¸</span>
      <h4>Reusability</h4>
      <p>Build the graph once. Run DFS paths, CC, cycle detection, and bipartiteness testing on the same object.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ§ª</span>
      <h4>Testability</h4>
      <p>Each class can be tested independently with small hand-crafted graphs.</p>
    </div>
    <div class="card">
      <span class="card-icon">ğŸ”Œ</span>
      <h4>Extensibility</h4>
      <p>Add new algorithms by creating new classes â€” never modify Graph. Articulation points? Just add a new class.</p>
    </div>
  </div>
</div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- Â§9  COMPLEXITY -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="sec-complexity">
<div class="container">
  <span class="section-num">SECTION 09</span>
  <h2 class="section-title">Time &amp; Space Complexity</h2>

  <h3>DFS is O(V + E)</h3>
  <p>This is the most important fact about DFS â€” it runs in <em>linear time</em> with respect to the size of the graph. Here's why:</p>

  <div class="steps scroll-reveal">
    <div class="step-item">
      <div class="step-num" style="background:var(--teal)">V</div>
      <div class="step-body">
        <h4>Each vertex is processed exactly once</h4>
        <p>The <span class="inline-mono">if (!marked[w])</span> guard ensures DFS(v) is called at most once per vertex. So across all recursive calls combined, we do O(V) total work just for the function calls themselves.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num" style="background:var(--amber)">E</div>
      <div class="step-body">
        <h4>Each edge is examined exactly twice</h4>
        <p>Every undirected edge {u,v} gets examined once from u's adjacency list and once from v's. The handshaking lemma tells us the sum of all adjacency list lengths = 2E. So we do O(E) work examining neighbors.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num" style="background:var(--green)">Î£</div>
      <div class="step-body">
        <h4>Total: O(V + E)</h4>
        <p>V work for vertices + 2E â‰ˆ E work for edges = <span class="complexity">O(V + E)</span>. This is <em>optimal</em> â€” any correct algorithm must at least read the entire graph.</p>
      </div>
    </div>
  </div>

  <table class="fancy-table scroll-reveal">
    <thead>
      <tr>
        <th>Algorithm</th>
        <th>Time</th>
        <th>Space</th>
        <th>Per Query After</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>DFS (single component)</td>
        <td class="good">O(V + E)</td>
        <td class="good">O(V)</td>
        <td>â€”</td>
      </tr>
      <tr>
        <td>DepthFirstPaths preprocessing</td>
        <td class="good">O(V + E)</td>
        <td class="good">O(V)</td>
        <td class="good">hasPathTo: O(1) Â· pathTo: O(length)</td>
      </tr>
      <tr>
        <td>ConnectedComponents preprocessing</td>
        <td class="good">O(V + E)</td>
        <td class="good">O(V)</td>
        <td class="good">connected(u,v): O(1)</td>
      </tr>
      <tr>
        <td>CycleDetection preprocessing</td>
        <td class="good">O(V + E)</td>
        <td class="good">O(V)</td>
        <td class="good">hasCycle: O(1)</td>
      </tr>
      <tr>
        <td>BipartiteTest preprocessing</td>
        <td class="good">O(V + E)</td>
        <td class="good">O(V)</td>
        <td class="good">isBipartite: O(1)</td>
      </tr>
    </tbody>
  </table>

  <div class="callout violet scroll-reveal">
    <span class="callout-label">The Preprocessing Paradigm</span>
    <p>Invest O(V+E) time upfront to build a data structure. Then answer each query in O(1) â€” constant time, no matter how large the graph. This is the power of the constructor-query pattern. One DFS buys you unlimited instant answers to structural questions.</p>
  </div>

  <h3>DFS vs BFS â€” Summary Comparison</h3>
  <table class="fancy-table scroll-reveal">
    <thead>
      <tr>
        <th>Property</th>
        <th>Depth-First Search</th>
        <th>Breadth-First Search</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Data structure</td>
        <td>Stack (implicit via recursion)</td>
        <td>Queue</td>
      </tr>
      <tr>
        <td>Exploration order</td>
        <td>Deep before wide</td>
        <td>Wide before deep (by distance)</td>
      </tr>
      <tr>
        <td>Path quality</td>
        <td class="warn">Some path (not shortest)</td>
        <td class="good">Shortest path (unweighted)</td>
      </tr>
      <tr>
        <td>Time complexity</td>
        <td class="good">O(V + E)</td>
        <td class="good">O(V + E)</td>
      </tr>
      <tr>
        <td>Best for</td>
        <td>Cycles, components, topological sort, SCC</td>
        <td>Shortest paths, levels, BFS trees</td>
      </tr>
    </tbody>
  </table>
</div>
</section>

<!-- BIPARTITE (bonus) -->
<section>
<div class="container">
  <span class="section-num">BONUS</span>
  <h2 class="section-title">Bipartiteness Testing</h2>
  <p>A bipartite graph is one whose vertices can be split into two groups such that every edge connects a vertex in group A to one in group B â€” never within the same group. This is equivalent to saying the graph contains no <em>odd-length cycle</em>.</p>

  <p>DFS tests bipartiteness with <strong>2-coloring</strong>: alternate colors as we traverse. If we ever try to color a vertex the same color as its neighbor, the graph is not bipartite.</p>

  <div class="graph-display scroll-reveal">
    <svg viewBox="0 0 700 250" width="700" height="250">
      <!-- BIPARTITE -->
      <text x="175" y="20" text-anchor="middle" fill="#3fb950" font-family="Nunito" font-size="13" font-weight="700">âœ“ Bipartite (even cycle)</text>
      <line x1="80" y1="80" x2="160" y2="150" stroke="#39d0d8" stroke-width="2"/>
      <line x1="80" y1="80" x2="270" y2="80" stroke="#39d0d8" stroke-width="2" stroke-dasharray="1"/>
      <line x1="80" y1="150" x2="160" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <line x1="160" y1="150" x2="270" y2="150" stroke="#39d0d8" stroke-width="2"/>
      <line x1="160" y1="80" x2="270" y2="150" stroke="#39d0d8" stroke-width="2"/>
      <line x1="270" y1="80" x2="270" y2="150" stroke="#39d0d8" stroke-width="2"/>

      <!-- Group A (color 0 = teal) -->
      <circle cx="80" cy="80" r="24" fill="rgba(57,208,216,0.2)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="80" y="85" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">0</text>
      <circle cx="160" cy="150" r="24" fill="rgba(57,208,216,0.2)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="160" y="155" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">2</text>
      <circle cx="270" cy="80" r="24" fill="rgba(57,208,216,0.2)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="270" y="85" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">4</text>

      <!-- Group B (color 1 = amber) -->
      <circle cx="80" cy="150" r="24" fill="rgba(240,168,48,0.2)" stroke="#f0a830" stroke-width="2.5"/>
      <text x="80" y="155" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="12">1</text>
      <circle cx="160" cy="80" r="24" fill="rgba(240,168,48,0.2)" stroke="#f0a830" stroke-width="2.5"/>
      <text x="160" y="85" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="12">3</text>
      <circle cx="270" cy="150" r="24" fill="rgba(240,168,48,0.2)" stroke="#f0a830" stroke-width="2.5"/>
      <text x="270" y="155" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="12">5</text>

      <text x="100" y="200" fill="#39d0d8" font-family="Nunito" font-size="11">â–  Group A: {0,2,4}</text>
      <text x="230" y="200" fill="#f0a830" font-family="Nunito" font-size="11">â–  Group B: {1,3,5}</text>
      <text x="175" y="220" text-anchor="middle" fill="#3fb950" font-family="Nunito" font-size="10">No edge within the same group â€” valid 2-coloring!</text>

      <!-- divider -->
      <line x1="370" y1="20" x2="370" y2="240" stroke="#30363d" stroke-width="1" stroke-dasharray="5,4"/>

      <!-- NOT BIPARTITE -->
      <text x="540" y="20" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="13" font-weight="700">âœ— Not Bipartite (odd cycle: triangle)</text>
      <line x1="450" y1="80" x2="550" y2="160" stroke="#39d0d8" stroke-width="2"/>
      <line x1="550" y1="160" x2="630" y2="80" stroke="#39d0d8" stroke-width="2"/>
      <line x1="450" y1="80" x2="630" y2="80" stroke="#ff6b6b" stroke-width="3" stroke-dasharray="6,3"/>

      <circle cx="450" cy="80" r="24" fill="rgba(57,208,216,0.2)" stroke="#39d0d8" stroke-width="2.5"/>
      <text x="450" y="75" text-anchor="middle" fill="#39d0d8" font-family="JetBrains Mono" font-size="12">0</text>
      <text x="450" y="90" text-anchor="middle" fill="#39d0d8" font-family="Nunito" font-size="8">color 0</text>

      <circle cx="550" cy="160" r="24" fill="rgba(240,168,48,0.2)" stroke="#f0a830" stroke-width="2.5"/>
      <text x="550" y="155" text-anchor="middle" fill="#f0a830" font-family="JetBrains Mono" font-size="12">1</text>
      <text x="550" y="170" text-anchor="middle" fill="#f0a830" font-family="Nunito" font-size="8">color 1</text>

      <circle cx="630" cy="80" r="24" fill="rgba(57,208,216,0.2)" stroke="#ff6b6b" stroke-width="2.5"/>
      <text x="630" y="75" text-anchor="middle" fill="#ff6b6b" font-family="JetBrains Mono" font-size="12">2</text>
      <text x="630" y="90" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="8">color 0 ??</text>

      <text x="540" y="200" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="11">Vertex 2 must be color 0 (like 0), but edge {0,2} would connect same colors!</text>
      <text x="540" y="220" text-anchor="middle" fill="#ff6b6b" font-family="Nunito" font-size="10">3-cycle (odd) â†’ impossible to 2-color â†’ NOT bipartite</text>
    </svg>
  </div>

  <div class="code-block scroll-reveal">
    <div class="code-header">
      <div class="code-dot red"></div><div class="code-dot yellow"></div><div class="code-dot green"></div>
      <span class="code-lang">Pseudocode Â· BipartiteTest Class</span>
    </div>
    <pre><span class="cm">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 BipartiteTest: 2-color the graph during DFS.
 Start by coloring source RED. All unvisited neighbors â†’ BLUE.
 All unvisited neighbors of BLUE â†’ RED. Repeat.
 If we must assign a vertex the SAME color as its neighbor:
   â†’ odd cycle found â†’ graph is NOT bipartite.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>

<span class="kw">class</span> <span class="ty">BipartiteTest</span>:

    marked[0..V-1] â† all false
    color[0..V-1]  â† all 0       <span class="cm">// 0 = RED, 1 = BLUE</span>
    isBipartite â† true

    <span class="cm">â”€â”€ Constructor â”€â”€</span>
    <span class="fn">BipartiteTest</span>(Graph G):
        <span class="kw">for</span> v <span class="kw">in</span> 0..V-1:
            <span class="kw">if</span> marked[v] = false:
                <span class="fn">dfs</span>(G, v)          <span class="cm">// handles disconnected graphs</span>

    <span class="cm">â”€â”€ Private: DFS with 2-coloring â”€â”€</span>
    <span class="fn">dfs</span>(Graph G, vertex v):
        marked[v] â† true

        <span class="kw">for each</span> neighbor w <span class="kw">of</span> v:

            <span class="kw">if</span> marked[w] = false:
                color[w] â† 1 - color[v]    <span class="cm">// flip: REDâ†’BLUE or BLUEâ†’RED</span>
                <span class="fn">dfs</span>(G, w)

            <span class="kw">else if</span> color[w] = color[v]:   <span class="cm">// neighbor has same color!</span>
                isBipartite â† false        <span class="cm">// odd cycle â†’ cannot 2-color</span>

    <span class="fn">isBipartite</span>() â†’ boolean: return isBipartite
    <span class="fn">colorOf</span>(vertex v) â†’ integer: return color[v]   <span class="cm">// which group is v in?</span></pre>
  </div>
</div>
</section>

<!-- SUMMARY -->
<section style="background:var(--bg2)">
<div class="container">
  <span class="section-num">SUMMARY</span>
  <h2 class="section-title">Key Takeaways</h2>

  <div class="card-grid scroll-reveal">
    <div class="card" style="border-color:var(--teal-dim)">
      <span class="card-icon">ğŸŒ</span>
      <h4>Graphs are Universal</h4>
      <p>Vertices + edges. That's it. But from this simplicity emerges the ability to model virtually everything: social networks, roads, the web, compilers, biology.</p>
    </div>
    <div class="card" style="border-color:rgba(240,168,48,0.3)">
      <span class="card-icon">ğŸ“Š</span>
      <h4>Adjacency List Wins</h4>
      <p>For sparse graphs (nearly all real graphs), use adjacency lists. O(V+E) space vs O(VÂ²). O(degree) neighbor iteration vs O(V).</p>
    </div>
    <div class="card" style="border-color:rgba(167,139,250,0.3)">
      <span class="card-icon">ğŸ”</span>
      <h4>DFS is Foundational</h4>
      <p>One linear-time traversal, powered by a marked[] array. The base for paths, components, cycles, bipartiteness, and eventually topological sort and SCCs.</p>
    </div>
    <div class="card" style="border-color:rgba(63,185,80,0.3)">
      <span class="card-icon">âš¡</span>
      <h4>O(V+E) is Optimal</h4>
      <p>Every vertex visited once. Every edge examined twice. O(V) setup for marked[]. Can't do better â€” must read the whole graph.</p>
    </div>
    <div class="card" style="border-color:rgba(255,107,107,0.3)">
      <span class="card-icon">ğŸŒ³</span>
      <h4>Back Edges = Cycles</h4>
      <p>An undirected graph has a cycle if and only if DFS finds a back edge. Tree edges span the graph; back edges create cycles.</p>
    </div>
    <div class="card" style="border-color:rgba(88,166,255,0.3)">
      <span class="card-icon">ğŸ—ï¸</span>
      <h4>Decouple Everything</h4>
      <p>Graph stores data. Separate classes implement algorithms. Build once, query in O(1). This is clean, extensible, testable code.</p>
    </div>
  </div>

  <div style="text-align:center;margin-top:3rem" class="scroll-reveal">
    <p style="color:var(--muted);font-family:'JetBrains Mono',monospace;font-size:0.85rem">Coming up in Lecture 10:</p>
    <p style="font-family:'DM Serif Display',serif;font-size:1.5rem;color:var(--teal)">Directed Graphs Â· Breadth-First Search Â· Topological Sort Â· Strongly Connected Components</p>
  </div>
</div>
</section>

<footer>
  <p>Based on <em>Algorithms, 4th Edition</em> by Sedgewick &amp; Wayne â€” Chapter 4.1 â€” Lecture 09 of 12</p>
</footer>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     JAVASCRIPT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â”€â”€ Scroll reveal â”€â”€
const observer = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
}, { threshold: 0.1 });
document.querySelectorAll('.scroll-reveal').forEach(el => observer.observe(el));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED INTERACTIVE DFS TRACE
// Graph: 0:[1,2,5] 1:[0,2] 2:[0,1,3,4] 3:[2,4,5] 4:[2,3] 5:[0,3]
// Features:
//   â€¢ Live call stack (right panel, grows/shrinks with recursion)
//   â€¢ Highlighted pseudocode line (center panel)
//   â€¢ Graph visualization (left panel, tree=amber, back=red)
//   â€¢ State arrays (marked[], edgeTo[], visit order)
//   â€¢ Scrollable log strip at bottom
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const dEdges = {
  '0-1':'d01','1-0':'d01','0-2':'d02','2-0':'d02','0-5':'d05','5-0':'d05',
  '1-2':'d12','2-1':'d12','2-3':'d23','3-2':'d23','2-4':'d24','4-2':'d24',
  '3-4':'d34','4-3':'d34','3-5':'d35','5-3':'d35'
};

// Each step: { pseudoLine, callStack, mark, edgeTo, treeEdge, backEdge,
//              activeNode, log, logType, visitOrder }
// callStack: array of strings like "dfs(0)", "dfs(1)" etc â€” full stack at this moment
// pseudoLine: 0â€“8 index into the pseudocode lines
const STEPS = [
  // â”€â”€ DFS(0) â”€â”€
  { pseudoLine:0, callStack:['dfs(0)'],
    activeNode:0, log:'â–¶ Call dfs(0). Begin DFS from source vertex 0.', logType:'call' },
  { pseudoLine:1, callStack:['dfs(0)'],
    mark:[0], activeNode:0, visitOrder:[0], log:'âœ“ marked[0] â† true. Vertex 0 claimed.', logType:'mark' },
  { pseudoLine:2, callStack:['dfs(0)'],
    activeNode:0, log:'  Scanning neighbors of 0: [1, 2, 5]', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)'],
    activeNode:0, log:'  Check neighbor 1: marked[1]=false â†’ unvisited', logType:'' },
  { pseudoLine:4, callStack:['dfs(0)'],
    edgeTo:{1:0}, activeNode:0, log:'  edgeTo[1] â† 0. Recording tree edge 0â†’1.', logType:'tree', treeEdge:'0-1' },
  { pseudoLine:5, callStack:['dfs(0)'],
    activeNode:1, log:'â–¶ Call dfs(1). Diving deeper.', logType:'call' },

  // â”€â”€ DFS(1) â”€â”€
  { pseudoLine:0, callStack:['dfs(0)','dfs(1)'],
    activeNode:1, log:'â–¶ Enter dfs(1).', logType:'call' },
  { pseudoLine:1, callStack:['dfs(0)','dfs(1)'],
    mark:[0,1], activeNode:1, visitOrder:[0,1], log:'âœ“ marked[1] â† true. Vertex 1 claimed.', logType:'mark' },
  { pseudoLine:2, callStack:['dfs(0)','dfs(1)'],
    activeNode:1, log:'  Scanning neighbors of 1: [0, 2]', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)'],
    activeNode:1, log:'  Check neighbor 0: marked[0]=true', logType:'' },
  { pseudoLine:6, callStack:['dfs(0)','dfs(1)'],
    activeNode:1, log:'  0 is our parent â†’ skip (not a back edge).', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)'],
    activeNode:1, log:'  Check neighbor 2: marked[2]=false â†’ unvisited', logType:'' },
  { pseudoLine:4, callStack:['dfs(0)','dfs(1)'],
    edgeTo:{1:0,2:1}, activeNode:1, log:'  edgeTo[2] â† 1. Tree edge 1â†’2.', logType:'tree', treeEdge:'1-2' },
  { pseudoLine:5, callStack:['dfs(0)','dfs(1)'],
    activeNode:2, log:'â–¶ Call dfs(2). Diving deeper.', logType:'call' },

  // â”€â”€ DFS(2) â”€â”€
  { pseudoLine:0, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'â–¶ Enter dfs(2).', logType:'call' },
  { pseudoLine:1, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    mark:[0,1,2], activeNode:2, visitOrder:[0,1,2], log:'âœ“ marked[2] â† true. Vertex 2 claimed.', logType:'mark' },
  { pseudoLine:2, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'  Scanning neighbors of 2: [0, 1, 3, 4]', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'  Check neighbor 0: marked[0]=true', logType:'' },
  { pseudoLine:6, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    backEdge:'2-0', activeNode:2, log:'ğŸ”´ BACK EDGE {2,0}! Neighbor 0 is an ancestor (not parent). Cycle: 0-1-2-0.', logType:'back' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'  Check neighbor 1: marked[1]=true (our parent) â†’ skip.', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'  Check neighbor 3: marked[3]=false â†’ unvisited', logType:'' },
  { pseudoLine:4, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    edgeTo:{1:0,2:1,3:2}, activeNode:2, log:'  edgeTo[3] â† 2. Tree edge 2â†’3.', logType:'tree', treeEdge:'2-3' },
  { pseudoLine:5, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:3, log:'â–¶ Call dfs(3). Diving deeper.', logType:'call' },

  // â”€â”€ DFS(3) â”€â”€
  { pseudoLine:0, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'â–¶ Enter dfs(3).', logType:'call' },
  { pseudoLine:1, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    mark:[0,1,2,3], activeNode:3, visitOrder:[0,1,2,3], log:'âœ“ marked[3] â† true. Vertex 3 claimed.', logType:'mark' },
  { pseudoLine:2, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'  Scanning neighbors of 3: [2, 4, 5]', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'  Check neighbor 2: marked[2]=true (our parent) â†’ skip.', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'  Check neighbor 4: marked[4]=false â†’ unvisited', logType:'' },
  { pseudoLine:4, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    edgeTo:{1:0,2:1,3:2,4:3}, activeNode:3, log:'  edgeTo[4] â† 3. Tree edge 3â†’4.', logType:'tree', treeEdge:'3-4' },
  { pseudoLine:5, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:4, log:'â–¶ Call dfs(4). Diving deeper.', logType:'call' },

  // â”€â”€ DFS(4) â”€â”€
  { pseudoLine:0, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(4)'],
    activeNode:4, log:'â–¶ Enter dfs(4).', logType:'call' },
  { pseudoLine:1, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(4)'],
    mark:[0,1,2,3,4], activeNode:4, visitOrder:[0,1,2,3,4], log:'âœ“ marked[4] â† true. Vertex 4 claimed.', logType:'mark' },
  { pseudoLine:2, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(4)'],
    activeNode:4, log:'  Scanning neighbors of 4: [2, 3]', logType:'' },
  { pseudoLine:6, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(4)'],
    backEdge:'4-2', activeNode:4, log:'ğŸ”´ BACK EDGE {4,2}! Neighbor 2 is an ancestor (not parent). Cycle: 2-3-4-2.', logType:'back' },
  { pseudoLine:6, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(4)'],
    activeNode:4, log:'  Neighbor 3: our parent â†’ skip.', logType:'' },
  { pseudoLine:8, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'â†© Return from dfs(4). Back in dfs(3).', logType:'ret' },

  // back in DFS(3)
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'  Check neighbor 5: marked[5]=false â†’ unvisited', logType:'' },
  { pseudoLine:4, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    edgeTo:{1:0,2:1,3:2,4:3,5:3}, activeNode:3, log:'  edgeTo[5] â† 3. Tree edge 3â†’5.', logType:'tree', treeEdge:'3-5' },
  { pseudoLine:5, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:5, log:'â–¶ Call dfs(5). Diving deeper.', logType:'call' },

  // â”€â”€ DFS(5) â”€â”€
  { pseudoLine:0, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(5)'],
    activeNode:5, log:'â–¶ Enter dfs(5).', logType:'call' },
  { pseudoLine:1, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(5)'],
    mark:[0,1,2,3,4,5], activeNode:5, visitOrder:[0,1,2,3,4,5], log:'âœ“ marked[5] â† true. All 6 vertices now marked!', logType:'mark' },
  { pseudoLine:2, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(5)'],
    activeNode:5, log:'  Scanning neighbors of 5: [0, 3]', logType:'' },
  { pseudoLine:6, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(5)'],
    backEdge:'5-0', activeNode:5, log:'ğŸ”´ BACK EDGE {5,0}! Neighbor 0 is an ancestor. Cycle: 0-1-2-3-5-0.', logType:'back' },
  { pseudoLine:6, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)','dfs(5)'],
    activeNode:5, log:'  Neighbor 3: our parent â†’ skip.', logType:'' },
  { pseudoLine:8, callStack:['dfs(0)','dfs(1)','dfs(2)','dfs(3)'],
    activeNode:3, log:'â†© Return from dfs(5). Back in dfs(3).', logType:'ret' },
  { pseudoLine:8, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'â†© Return from dfs(3). Back in dfs(2).', logType:'ret' },

  // back in DFS(2) â€” check neighbor 4
  { pseudoLine:3, callStack:['dfs(0)','dfs(1)','dfs(2)'],
    activeNode:2, log:'  Check neighbor 4: marked[4]=true â†’ skip.', logType:'' },
  { pseudoLine:8, callStack:['dfs(0)','dfs(1)'],
    activeNode:1, log:'â†© Return from dfs(2). Back in dfs(1).', logType:'ret' },
  { pseudoLine:8, callStack:['dfs(0)'],
    activeNode:0, log:'â†© Return from dfs(1). Back in dfs(0).', logType:'ret' },

  // back in DFS(0) â€” check 2 and 5
  { pseudoLine:3, callStack:['dfs(0)'],
    activeNode:0, log:'  Check neighbor 2: marked[2]=true â†’ skip.', logType:'' },
  { pseudoLine:3, callStack:['dfs(0)'],
    activeNode:0, log:'  Check neighbor 5: marked[5]=true â†’ skip.', logType:'' },
  { pseudoLine:8, callStack:[],
    activeNode:-1, log:'â†© Return from dfs(0). Call stack empty!', logType:'ret' },

  // Done
  { pseudoLine:-1, callStack:[],
    log:'ğŸ‰ DFS complete! Visit order: 0â†’1â†’2â†’3â†’4â†’5. Tree edges: 0-1,1-2,2-3,3-4,3-5. Back edges: {0,2},{2,4},{0,5}.', logType:'done' }
];

// â”€â”€ State â”€â”€
let dStep = -1;
let dMarked = new Set();
let dEdgeTo = {};
let dVisitOrder = [];
let dTreeEdges = new Set();
let dBackEdges = new Set();

function dColorNode(v, state) {
  const c = document.getElementById('dc'+v);
  const t = document.getElementById('dt'+v);
  if (!c) return;
  if (state === 'active') {
    c.setAttribute('fill', 'rgba(240,168,48,0.25)');
    c.setAttribute('stroke', '#f0a830');
    c.setAttribute('stroke-width', '3');
    t.setAttribute('fill', '#f0a830');
  } else if (state === 'marked') {
    c.setAttribute('fill', 'rgba(63,185,80,0.12)');
    c.setAttribute('stroke', '#3fb950');
    c.setAttribute('stroke-width', '2');
    t.setAttribute('fill', '#3fb950');
  } else {
    c.setAttribute('fill', '#161b22');
    c.setAttribute('stroke', '#30363d');
    c.setAttribute('stroke-width', '2');
    t.setAttribute('fill', '#8b949e');
  }
}

function dColorEdge(key, state) {
  const id = dEdges[key];
  if (!id) return;
  const el = document.getElementById(id);
  if (!el) return;
  if (state === 'tree') {
    el.setAttribute('stroke', '#f0a830');
    el.setAttribute('stroke-width', '3');
    el.removeAttribute('stroke-dasharray');
  } else if (state === 'back') {
    el.setAttribute('stroke', '#ff6b6b');
    el.setAttribute('stroke-width', '2.5');
    el.setAttribute('stroke-dasharray', '7,4');
  } else {
    el.setAttribute('stroke', '#30363d');
    el.setAttribute('stroke-width', '2');
    el.removeAttribute('stroke-dasharray');
  }
}

function dHighlightLine(idx) {
  for (let i = 0; i <= 8; i++) {
    const el = document.getElementById('pl'+i);
    if (!el) continue;
    el.classList.remove('active', 'done');
    if (i === idx) el.classList.add('active');
    else if (i < idx) el.classList.add('done');
  }
}

function dRenderCallStack(stack) {
  const el = document.getElementById('callStack2');
  const empty = document.getElementById('stackEmpty2');
  if (!stack.length) {
    el.innerHTML = '<div class="stack-empty" id="stackEmpty2">empty</div>';
    return;
  }
  el.innerHTML = '';
  stack.forEach((frame, i) => {
    const div = document.createElement('div');
    div.className = 'stack-frame' + (i === stack.length-1 ? ' top-frame' : '');
    const depth = i;
    div.innerHTML = `<span class="stack-frame-label">${frame}</span><span class="stack-frame-state">depth ${depth}</span>`;
    el.appendChild(div);
  });
}

function dUpdateStateUI(step) {
  for (let i = 0; i < 6; i++) {
    const mEl = document.getElementById('sm'+i);
    const eEl = document.getElementById('se'+i);
    mEl.className = 'sc2' + (dMarked.has(i) ? ' marked' : '');
    mEl.textContent = dMarked.has(i) ? 'T' : 'F';
    eEl.textContent = (dEdgeTo[i] !== undefined) ? dEdgeTo[i] : 'âˆ’';
  }
  // active node highlight on state cells
  if (step.activeNode !== undefined && step.activeNode >= 0) {
    const mEl = document.getElementById('sm'+step.activeNode);
    if (mEl && !dMarked.has(step.activeNode)) {
      mEl.className = 'sc2 current';
    }
  }
  document.getElementById('visitOrder2').textContent =
    dVisitOrder.length ? dVisitOrder.join(' â†’ ') : 'â€”';
}

function dAddLog(step) {
  const log = document.getElementById('traceLog2');
  const div = document.createElement('div');
  div.className = 'tl-entry tl-' + (step.logType||'') + ' tl-active';
  // Remove active from previous
  log.querySelectorAll('.tl-active').forEach(e => e.classList.remove('tl-active'));
  div.textContent = step.log;
  log.appendChild(div);
  div.scrollIntoView({ behavior:'smooth', block:'nearest' });
}

function nextStep2() {
  if (dStep >= STEPS.length - 1) return;
  dStep++;
  const step = STEPS[dStep];

  // â”€â”€ Reset all node colors to base â”€â”€
  for (let i = 0; i < 6; i++) {
    dColorNode(i, dMarked.has(i) ? 'marked' : 'none');
  }

  // â”€â”€ Apply step â”€â”€
  if (step.mark) {
    step.mark.forEach(v => dMarked.add(v));
  }
  if (step.edgeTo) {
    Object.assign(dEdgeTo, step.edgeTo);
  }
  if (step.visitOrder) {
    dVisitOrder = step.visitOrder.slice();
  }
  if (step.treeEdge) {
    dTreeEdges.add(step.treeEdge);
    dColorEdge(step.treeEdge, 'tree');
  }
  if (step.backEdge) {
    dBackEdges.add(step.backEdge);
    dColorEdge(step.backEdge, 'back');
  }

  // Re-apply all tree/back edges (in case reset happened)
  dTreeEdges.forEach(e => dColorEdge(e, 'tree'));
  dBackEdges.forEach(e => dColorEdge(e, 'back'));

  // Color nodes
  for (let i = 0; i < 6; i++) {
    dColorNode(i, dMarked.has(i) ? 'marked' : 'none');
  }
  if (step.activeNode !== undefined && step.activeNode >= 0) {
    dColorNode(step.activeNode, 'active');
  }

  // â”€â”€ Update UI â”€â”€
  dHighlightLine(step.pseudoLine);
  dRenderCallStack(step.callStack || []);
  dUpdateStateUI(step);
  dAddLog(step);

  // Step counter
  document.getElementById('stepCount2').textContent = `Step ${dStep+1} / ${STEPS.length}`;

  if (dStep >= STEPS.length - 1) {
    const btn = document.getElementById('nextBtn2');
    btn.textContent = 'Done âœ“';
    btn.disabled = true;
  }
}

function resetTrace2() {
  dStep = -1;
  dMarked.clear();
  dEdgeTo = {};
  dVisitOrder = [];
  dTreeEdges.clear();
  dBackEdges.clear();

  for (let i = 0; i < 6; i++) {
    dColorNode(i, 'none');
    document.getElementById('sm'+i).className = 'sc2';
    document.getElementById('sm'+i).textContent = 'F';
    document.getElementById('se'+i).textContent = 'âˆ’';
  }
  // Reset edges
  Object.values(dEdges).forEach(id => {
    const el = document.getElementById(id);
    if (el) { el.setAttribute('stroke','#30363d'); el.setAttribute('stroke-width','2'); el.removeAttribute('stroke-dasharray'); }
  });
  // Reset pseudocode
  for (let i = 0; i <= 8; i++) {
    const el = document.getElementById('pl'+i);
    if (el) el.className = 'pseudo-line';
  }
  // Reset call stack
  document.getElementById('callStack2').innerHTML = '<div class="stack-empty" id="stackEmpty2">empty</div>';
  // Reset log
  document.getElementById('traceLog2').innerHTML = '<div class="tl-entry">ğŸš€ Press "Next Step" to start DFS from vertex 0.</div>';
  // Reset counter
  document.getElementById('stepCount2').textContent = `Step 0 / ${STEPS.length}`;
  document.getElementById('visitOrder2').textContent = 'â€”';
  // Re-enable button
  const btn = document.getElementById('nextBtn2');
  btn.textContent = 'Next Step â†’';
  btn.disabled = false;
}
</script>
</body>
</html>
